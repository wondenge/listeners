// Code generated by goa v3.1.2, DO NOT EDIT.
//
// mpesa HTTP server types
//
// Command:
// $ goa gen github.com/wondenge/listeners/design

package server

import (
	"unicode/utf8"

	mpesa "github.com/wondenge/listeners/gen/mpesa"
	goa "goa.design/goa/v3/pkg"
)

// AccountBalanceTimeoutRequestBody is the type of the "mpesa" service
// "AccountBalanceTimeout" endpoint HTTP request body.
type AccountBalanceTimeoutRequestBody struct {
	ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
	OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
	ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
	TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	ResultParameters         *struct {
		ResultParameter *struct {
			AccountBalance  map[string]string `form:"AccountBalance,omitempty" json:"AccountBalance,omitempty" xml:"AccountBalance,omitempty"`
			BOCompletedTime map[string]string `form:"BOCompletedTime,omitempty" json:"BOCompletedTime,omitempty" xml:"BOCompletedTime,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// AccountBalanceResultRequestBody is the type of the "mpesa" service
// "AccountBalanceResult" endpoint HTTP request body.
type AccountBalanceResultRequestBody struct {
	ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
	OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
	ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
	TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	ResultParameters         *struct {
		ResultParameter *struct {
			AccountBalance  map[string]string `form:"AccountBalance,omitempty" json:"AccountBalance,omitempty" xml:"AccountBalance,omitempty"`
			BOCompletedTime map[string]string `form:"BOCompletedTime,omitempty" json:"BOCompletedTime,omitempty" xml:"BOCompletedTime,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// TransactionStatusTimeoutRequestBody is the type of the "mpesa" service
// "TransactionStatusTimeout" endpoint HTTP request body.
type TransactionStatusTimeoutRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ResultParameters         *struct {
			ResultParameter *struct {
				ReceiptNo                map[string]string `form:"ReceiptNo,omitempty" json:"ReceiptNo,omitempty" xml:"ReceiptNo,omitempty"`
				ConversationID           map[string]string `form:"Conversation ID,omitempty" json:"Conversation ID,omitempty" xml:"Conversation ID,omitempty"`
				FinalisedTime            map[string]int    `form:"FinalisedTime,omitempty" json:"FinalisedTime,omitempty" xml:"FinalisedTime,omitempty"`
				Amount                   map[string]int    `form:"Amount,omitempty" json:"Amount,omitempty" xml:"Amount,omitempty"`
				TransactionStatus        map[string]string `form:"TransactionStatus,omitempty" json:"TransactionStatus,omitempty" xml:"TransactionStatus,omitempty"`
				ReasonType               map[string]string `form:"ReasonType,omitempty" json:"ReasonType,omitempty" xml:"ReasonType,omitempty"`
				TransactionReason        map[string]string `form:"TransactionReason,omitempty" json:"TransactionReason,omitempty" xml:"TransactionReason,omitempty"`
				DebitPartyCharges        map[string]string `form:"DebitPartyCharges,omitempty" json:"DebitPartyCharges,omitempty" xml:"DebitPartyCharges,omitempty"`
				DebitAccountType         map[string]string `form:"DebitAccountType,omitempty" json:"DebitAccountType,omitempty" xml:"DebitAccountType,omitempty"`
				InitiatedTime            map[string]int    `form:"InitiatedTime,omitempty" json:"InitiatedTime,omitempty" xml:"InitiatedTime,omitempty"`
				OriginatorConversationID map[string]string `form:"Originator Conversation ID,omitempty" json:"Originator Conversation ID,omitempty" xml:"Originator Conversation ID,omitempty"`
				CreditPartyName          map[string]string `form:"CreditPartyName,omitempty" json:"CreditPartyName,omitempty" xml:"CreditPartyName,omitempty"`
				DebitPartyName           map[string]string `form:"DebitPartyName,omitempty" json:"DebitPartyName,omitempty" xml:"DebitPartyName,omitempty"`
			} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
		} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
		ReferenceData *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// TransactionStatusResultRequestBody is the type of the "mpesa" service
// "TransactionStatusResult" endpoint HTTP request body.
type TransactionStatusResultRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ResultParameters         *struct {
			ResultParameter *struct {
				ReceiptNo                map[string]string `form:"ReceiptNo,omitempty" json:"ReceiptNo,omitempty" xml:"ReceiptNo,omitempty"`
				ConversationID           map[string]string `form:"Conversation ID,omitempty" json:"Conversation ID,omitempty" xml:"Conversation ID,omitempty"`
				FinalisedTime            map[string]int    `form:"FinalisedTime,omitempty" json:"FinalisedTime,omitempty" xml:"FinalisedTime,omitempty"`
				Amount                   map[string]int    `form:"Amount,omitempty" json:"Amount,omitempty" xml:"Amount,omitempty"`
				TransactionStatus        map[string]string `form:"TransactionStatus,omitempty" json:"TransactionStatus,omitempty" xml:"TransactionStatus,omitempty"`
				ReasonType               map[string]string `form:"ReasonType,omitempty" json:"ReasonType,omitempty" xml:"ReasonType,omitempty"`
				TransactionReason        map[string]string `form:"TransactionReason,omitempty" json:"TransactionReason,omitempty" xml:"TransactionReason,omitempty"`
				DebitPartyCharges        map[string]string `form:"DebitPartyCharges,omitempty" json:"DebitPartyCharges,omitempty" xml:"DebitPartyCharges,omitempty"`
				DebitAccountType         map[string]string `form:"DebitAccountType,omitempty" json:"DebitAccountType,omitempty" xml:"DebitAccountType,omitempty"`
				InitiatedTime            map[string]int    `form:"InitiatedTime,omitempty" json:"InitiatedTime,omitempty" xml:"InitiatedTime,omitempty"`
				OriginatorConversationID map[string]string `form:"Originator Conversation ID,omitempty" json:"Originator Conversation ID,omitempty" xml:"Originator Conversation ID,omitempty"`
				CreditPartyName          map[string]string `form:"CreditPartyName,omitempty" json:"CreditPartyName,omitempty" xml:"CreditPartyName,omitempty"`
				DebitPartyName           map[string]string `form:"DebitPartyName,omitempty" json:"DebitPartyName,omitempty" xml:"DebitPartyName,omitempty"`
			} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
		} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
		ReferenceData *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// ReversalTimeoutRequestBody is the type of the "mpesa" service
// "ReversalTimeout" endpoint HTTP request body.
type ReversalTimeoutRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ReferenceData            *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// ReversalResultRequestBody is the type of the "mpesa" service
// "ReversalResult" endpoint HTTP request body.
type ReversalResultRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ReferenceData            *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// B2CTimeoutRequestBody is the type of the "mpesa" service "B2CTimeout"
// endpoint HTTP request body.
type B2CTimeoutRequestBody struct {
	Result *struct {
		// Status code that indicates whether the transaction was already sent
		ResultType *int `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		// Numeric status code that indicates the status of the transaction processing
		ResultCode *int `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		// Message from the API that gives the status of the request
		ResultDesc *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		// Global unique identifier for the transaction request.
		OriginatorConversationID *string `form:"OriginatorConversationId,omitempty" json:"OriginatorConversationId,omitempty" xml:"OriginatorConversationId,omitempty"`
		// Global unique identifier for the transaction request.
		ConversationID *string `form:"ConversationId,omitempty" json:"ConversationId,omitempty" xml:"ConversationId,omitempty"`
		// Unique M-PESA transaction ID for every payment request.
		TransactionID *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
	ResultParameters *struct {
		ResultParameter *struct {
			// This is a unique M-PESA transaction ID for every payment request.
			TransactionReceipt map[string]string `form:"TransactionReceipt,omitempty" json:"TransactionReceipt,omitempty" xml:"TransactionReceipt,omitempty"`
			// This is the amount that was transacted.
			TransactionAmount map[string]int `form:"TransactionAmount,omitempty" json:"TransactionAmount,omitempty" xml:"TransactionAmount,omitempty"`
			// Available balance of the Working account under the B2C shortcode used in the
			// transaction.
			B2CWorkingAccountAvailableFunds map[string]int `form:"B2CWorkingAccountAvailableFunds,omitempty" json:"B2CWorkingAccountAvailableFunds,omitempty" xml:"B2CWorkingAccountAvailableFunds,omitempty"`
			// Available balance of the Utility account under the B2C shortcode used in the
			// transaction.
			B2CUtilityAccountAvailableFunds map[string]int `form:"B2CUtilityAccountAvailableFunds,omitempty" json:"B2CUtilityAccountAvailableFunds,omitempty" xml:"B2CUtilityAccountAvailableFunds,omitempty"`
			// This is the date and time that the transaction completed M-PESA.
			TransactionCompletedDateTime map[string]string `form:"TransactionCompletedDateTime,omitempty" json:"TransactionCompletedDateTime,omitempty" xml:"TransactionCompletedDateTime,omitempty"`
			// This is the name and phone number of the customer who received the payment.
			ReceiverPartyPublicName map[string]string `form:"ReceiverPartyPublicName,omitempty" json:"ReceiverPartyPublicName,omitempty" xml:"ReceiverPartyPublicName,omitempty"`
			// Available balance of the Charges Paid account under the B2C shortcode used
			// in the transaction.
			B2CChargesPaidAccountAvailableFunds map[string]int `form:"B2CChargesPaidAccountAvailableFunds,omitempty" json:"B2CChargesPaidAccountAvailableFunds,omitempty" xml:"B2CChargesPaidAccountAvailableFunds,omitempty"`
			// This is a key that indicates whether the customer is a M-PESA registered
			// customer or not
			B2CRecipientIsRegisteredCustomer map[string]string `form:"B2CRecipientIsRegisteredCustomer,omitempty" json:"B2CRecipientIsRegisteredCustomer,omitempty" xml:"B2CRecipientIsRegisteredCustomer,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// B2CResultRequestBody is the type of the "mpesa" service "B2CResult" endpoint
// HTTP request body.
type B2CResultRequestBody struct {
	Result *struct {
		// Status code that indicates whether the transaction was already sent
		ResultType *int `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		// Numeric status code that indicates the status of the transaction processing
		ResultCode *int `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		// Message from the API that gives the status of the request
		ResultDesc *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		// Global unique identifier for the transaction request.
		OriginatorConversationID *string `form:"OriginatorConversationId,omitempty" json:"OriginatorConversationId,omitempty" xml:"OriginatorConversationId,omitempty"`
		// Global unique identifier for the transaction request.
		ConversationID *string `form:"ConversationId,omitempty" json:"ConversationId,omitempty" xml:"ConversationId,omitempty"`
		// Unique M-PESA transaction ID for every payment request.
		TransactionID *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
	ResultParameters *struct {
		ResultParameter *struct {
			// This is a unique M-PESA transaction ID for every payment request.
			TransactionReceipt map[string]string `form:"TransactionReceipt,omitempty" json:"TransactionReceipt,omitempty" xml:"TransactionReceipt,omitempty"`
			// This is the amount that was transacted.
			TransactionAmount map[string]int `form:"TransactionAmount,omitempty" json:"TransactionAmount,omitempty" xml:"TransactionAmount,omitempty"`
			// Available balance of the Working account under the B2C shortcode used in the
			// transaction.
			B2CWorkingAccountAvailableFunds map[string]int `form:"B2CWorkingAccountAvailableFunds,omitempty" json:"B2CWorkingAccountAvailableFunds,omitempty" xml:"B2CWorkingAccountAvailableFunds,omitempty"`
			// Available balance of the Utility account under the B2C shortcode used in the
			// transaction.
			B2CUtilityAccountAvailableFunds map[string]int `form:"B2CUtilityAccountAvailableFunds,omitempty" json:"B2CUtilityAccountAvailableFunds,omitempty" xml:"B2CUtilityAccountAvailableFunds,omitempty"`
			// This is the date and time that the transaction completed M-PESA.
			TransactionCompletedDateTime map[string]string `form:"TransactionCompletedDateTime,omitempty" json:"TransactionCompletedDateTime,omitempty" xml:"TransactionCompletedDateTime,omitempty"`
			// This is the name and phone number of the customer who received the payment.
			ReceiverPartyPublicName map[string]string `form:"ReceiverPartyPublicName,omitempty" json:"ReceiverPartyPublicName,omitempty" xml:"ReceiverPartyPublicName,omitempty"`
			// Available balance of the Charges Paid account under the B2C shortcode used
			// in the transaction.
			B2CChargesPaidAccountAvailableFunds map[string]int `form:"B2CChargesPaidAccountAvailableFunds,omitempty" json:"B2CChargesPaidAccountAvailableFunds,omitempty" xml:"B2CChargesPaidAccountAvailableFunds,omitempty"`
			// This is a key that indicates whether the customer is a M-PESA registered
			// customer or not
			B2CRecipientIsRegisteredCustomer map[string]string `form:"B2CRecipientIsRegisteredCustomer,omitempty" json:"B2CRecipientIsRegisteredCustomer,omitempty" xml:"B2CRecipientIsRegisteredCustomer,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// C2BValidationRequestBody is the type of the "mpesa" service "C2BValidation"
// endpoint HTTP request body.
type C2BValidationRequestBody struct {
	// The transaction type specified during the payment request.
	TransactionType *string `form:"TransactionType,omitempty" json:"TransactionType,omitempty" xml:"TransactionType,omitempty"`
	// Unique M-Pesa transaction ID for every payment request
	TransID *string `form:"TransID,omitempty" json:"TransID,omitempty" xml:"TransID,omitempty"`
	// Timestamp of the transaction
	TransTime *string `form:"TransTime,omitempty" json:"TransTime,omitempty" xml:"TransTime,omitempty"`
	// The Amount transacted normally a numeric value
	TransAmount *int `form:"TransAmount,omitempty" json:"TransAmount,omitempty" xml:"TransAmount,omitempty"`
	// Organizations shortcode (Paybill or Buygoods)
	BusinessShortCode *int `form:"BusinessShortCode,omitempty" json:"BusinessShortCode,omitempty" xml:"BusinessShortCode,omitempty"`
	// Account number for which the customer is making the payment
	BillRefNumber *string `form:"BillRefNumber,omitempty" json:"BillRefNumber,omitempty" xml:"BillRefNumber,omitempty"`
	InvoiceNumber *string `form:"InvoiceNumber,omitempty" json:"InvoiceNumber,omitempty" xml:"InvoiceNumber,omitempty"`
	// Current utility account balance of the payment receiving organization
	// shortcode
	OrgAccountBalance *int    `form:"OrgAccountBalance,omitempty" json:"OrgAccountBalance,omitempty" xml:"OrgAccountBalance,omitempty"`
	ThirdPartyTransID *string `form:"ThirdPartyTransID,omitempty" json:"ThirdPartyTransID,omitempty" xml:"ThirdPartyTransID,omitempty"`
	// Mobile number of the customer making the payment.
	MSISDN *int `form:"MSISDN,omitempty" json:"MSISDN,omitempty" xml:"MSISDN,omitempty"`
	// First Name of the customer making the payment.
	FirstName *string `form:"FirstName,omitempty" json:"FirstName,omitempty" xml:"FirstName,omitempty"`
	// Middle Name of the customer making the payment.
	MiddleName *string `form:"MiddleName,omitempty" json:"MiddleName,omitempty" xml:"MiddleName,omitempty"`
	// Last Name of the customer making payment.
	LastName *string `form:"LastName,omitempty" json:"LastName,omitempty" xml:"LastName,omitempty"`
}

// C2BConfirmationRequestBody is the type of the "mpesa" service
// "C2BConfirmation" endpoint HTTP request body.
type C2BConfirmationRequestBody struct {
	// The transaction type specified during the payment request.
	TransactionType *string `form:"TransactionType,omitempty" json:"TransactionType,omitempty" xml:"TransactionType,omitempty"`
	// Unique M-Pesa transaction ID for every payment request
	TransID *string `form:"TransID,omitempty" json:"TransID,omitempty" xml:"TransID,omitempty"`
	// Timestamp of the transaction
	TransTime *string `form:"TransTime,omitempty" json:"TransTime,omitempty" xml:"TransTime,omitempty"`
	// The Amount transacted normally a numeric value
	TransAmount *int `form:"TransAmount,omitempty" json:"TransAmount,omitempty" xml:"TransAmount,omitempty"`
	// Organizations shortcode (Paybill or Buygoods)
	BusinessShortCode *int `form:"BusinessShortCode,omitempty" json:"BusinessShortCode,omitempty" xml:"BusinessShortCode,omitempty"`
	// Account number for which the customer is making the payment
	BillRefNumber *string `form:"BillRefNumber,omitempty" json:"BillRefNumber,omitempty" xml:"BillRefNumber,omitempty"`
	InvoiceNumber *string `form:"InvoiceNumber,omitempty" json:"InvoiceNumber,omitempty" xml:"InvoiceNumber,omitempty"`
	// Current utility account balance of the payment receiving organization
	// shortcode
	OrgAccountBalance *int    `form:"OrgAccountBalance,omitempty" json:"OrgAccountBalance,omitempty" xml:"OrgAccountBalance,omitempty"`
	ThirdPartyTransID *string `form:"ThirdPartyTransID,omitempty" json:"ThirdPartyTransID,omitempty" xml:"ThirdPartyTransID,omitempty"`
	// Mobile number of the customer making the payment.
	MSISDN *int `form:"MSISDN,omitempty" json:"MSISDN,omitempty" xml:"MSISDN,omitempty"`
	// First Name of the customer making the payment.
	FirstName *string `form:"FirstName,omitempty" json:"FirstName,omitempty" xml:"FirstName,omitempty"`
	// Middle Name of the customer making the payment.
	MiddleName *string `form:"MiddleName,omitempty" json:"MiddleName,omitempty" xml:"MiddleName,omitempty"`
	// Last Name of the customer making payment.
	LastName *string `form:"LastName,omitempty" json:"LastName,omitempty" xml:"LastName,omitempty"`
}

// NewAccountBalanceTimeoutAccountBalanceResult builds a mpesa service
// AccountBalanceTimeout endpoint payload.
func NewAccountBalanceTimeoutAccountBalanceResult(body *AccountBalanceTimeoutRequestBody) *mpesa.AccountBalanceResult {
	v := &mpesa.AccountBalanceResult{
		ResultType:               body.ResultType,
		ResultCode:               body.ResultCode,
		ResultDesc:               body.ResultDesc,
		OriginatorConversationID: body.OriginatorConversationID,
		ConversationID:           body.ConversationID,
		TransactionID:            body.TransactionID,
	}
	if body.ResultParameters != nil {
		v.ResultParameters = &struct {
			ResultParameter *struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}
		}{}
		if body.ResultParameters.ResultParameter != nil {
			v.ResultParameters.ResultParameter = &struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}{}
			if body.ResultParameters.ResultParameter.AccountBalance != nil {
				v.ResultParameters.ResultParameter.AccountBalance = make(map[string]string, len(body.ResultParameters.ResultParameter.AccountBalance))
				for key, val := range body.ResultParameters.ResultParameter.AccountBalance {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.AccountBalance[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.BOCompletedTime != nil {
				v.ResultParameters.ResultParameter.BOCompletedTime = make(map[string]string, len(body.ResultParameters.ResultParameter.BOCompletedTime))
				for key, val := range body.ResultParameters.ResultParameter.BOCompletedTime {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.BOCompletedTime[tk] = tv
				}
			}
		}
	}
	if body.ReferenceData != nil {
		v.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if body.ReferenceData.ReferenceItem != nil {
			v.ReferenceData.ReferenceItem = make(map[string]string, len(body.ReferenceData.ReferenceItem))
			for key, val := range body.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				v.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}

	return v
}

// NewAccountBalanceResult builds a mpesa service AccountBalanceResult endpoint
// payload.
func NewAccountBalanceResult(body *AccountBalanceResultRequestBody) *mpesa.AccountBalanceResult {
	v := &mpesa.AccountBalanceResult{
		ResultType:               body.ResultType,
		ResultCode:               body.ResultCode,
		ResultDesc:               body.ResultDesc,
		OriginatorConversationID: body.OriginatorConversationID,
		ConversationID:           body.ConversationID,
		TransactionID:            body.TransactionID,
	}
	if body.ResultParameters != nil {
		v.ResultParameters = &struct {
			ResultParameter *struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}
		}{}
		if body.ResultParameters.ResultParameter != nil {
			v.ResultParameters.ResultParameter = &struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}{}
			if body.ResultParameters.ResultParameter.AccountBalance != nil {
				v.ResultParameters.ResultParameter.AccountBalance = make(map[string]string, len(body.ResultParameters.ResultParameter.AccountBalance))
				for key, val := range body.ResultParameters.ResultParameter.AccountBalance {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.AccountBalance[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.BOCompletedTime != nil {
				v.ResultParameters.ResultParameter.BOCompletedTime = make(map[string]string, len(body.ResultParameters.ResultParameter.BOCompletedTime))
				for key, val := range body.ResultParameters.ResultParameter.BOCompletedTime {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.BOCompletedTime[tk] = tv
				}
			}
		}
	}
	if body.ReferenceData != nil {
		v.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if body.ReferenceData.ReferenceItem != nil {
			v.ReferenceData.ReferenceItem = make(map[string]string, len(body.ReferenceData.ReferenceItem))
			for key, val := range body.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				v.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}

	return v
}

// NewTransactionStatusTimeoutTransactionStatusResult builds a mpesa service
// TransactionStatusTimeout endpoint payload.
func NewTransactionStatusTimeoutTransactionStatusResult(body *TransactionStatusTimeoutRequestBody) *mpesa.TransactionStatusResult {
	v := &mpesa.TransactionStatusResult{}
	if body.Result != nil {
		v.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ResultParameters         *struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}
			ReferenceData *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               body.Result.ResultType,
			ResultCode:               body.Result.ResultCode,
			ResultDesc:               body.Result.ResultDesc,
			OriginatorConversationID: body.Result.OriginatorConversationID,
			ConversationID:           body.Result.ConversationID,
			TransactionID:            body.Result.TransactionID,
		}
		if body.Result.ResultParameters != nil {
			v.Result.ResultParameters = &struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}{}
			if body.Result.ResultParameters.ResultParameter != nil {
				v.Result.ResultParameters.ResultParameter = &struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}{}
				if body.Result.ResultParameters.ResultParameter.ReceiptNo != nil {
					v.Result.ResultParameters.ResultParameter.ReceiptNo = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.ReceiptNo))
					for key, val := range body.Result.ResultParameters.ResultParameter.ReceiptNo {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.ReceiptNo[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.ConversationID != nil {
					v.Result.ResultParameters.ResultParameter.ConversationID = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.ConversationID))
					for key, val := range body.Result.ResultParameters.ResultParameter.ConversationID {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.ConversationID[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.FinalisedTime != nil {
					v.Result.ResultParameters.ResultParameter.FinalisedTime = make(map[string]int, len(body.Result.ResultParameters.ResultParameter.FinalisedTime))
					for key, val := range body.Result.ResultParameters.ResultParameter.FinalisedTime {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.FinalisedTime[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.Amount != nil {
					v.Result.ResultParameters.ResultParameter.Amount = make(map[string]int, len(body.Result.ResultParameters.ResultParameter.Amount))
					for key, val := range body.Result.ResultParameters.ResultParameter.Amount {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.Amount[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.TransactionStatus != nil {
					v.Result.ResultParameters.ResultParameter.TransactionStatus = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.TransactionStatus))
					for key, val := range body.Result.ResultParameters.ResultParameter.TransactionStatus {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.TransactionStatus[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.ReasonType != nil {
					v.Result.ResultParameters.ResultParameter.ReasonType = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.ReasonType))
					for key, val := range body.Result.ResultParameters.ResultParameter.ReasonType {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.ReasonType[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.TransactionReason != nil {
					v.Result.ResultParameters.ResultParameter.TransactionReason = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.TransactionReason))
					for key, val := range body.Result.ResultParameters.ResultParameter.TransactionReason {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.TransactionReason[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.DebitPartyCharges != nil {
					v.Result.ResultParameters.ResultParameter.DebitPartyCharges = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.DebitPartyCharges))
					for key, val := range body.Result.ResultParameters.ResultParameter.DebitPartyCharges {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.DebitPartyCharges[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.DebitAccountType != nil {
					v.Result.ResultParameters.ResultParameter.DebitAccountType = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.DebitAccountType))
					for key, val := range body.Result.ResultParameters.ResultParameter.DebitAccountType {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.DebitAccountType[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.InitiatedTime != nil {
					v.Result.ResultParameters.ResultParameter.InitiatedTime = make(map[string]int, len(body.Result.ResultParameters.ResultParameter.InitiatedTime))
					for key, val := range body.Result.ResultParameters.ResultParameter.InitiatedTime {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.InitiatedTime[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.OriginatorConversationID != nil {
					v.Result.ResultParameters.ResultParameter.OriginatorConversationID = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.OriginatorConversationID))
					for key, val := range body.Result.ResultParameters.ResultParameter.OriginatorConversationID {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.OriginatorConversationID[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.CreditPartyName != nil {
					v.Result.ResultParameters.ResultParameter.CreditPartyName = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.CreditPartyName))
					for key, val := range body.Result.ResultParameters.ResultParameter.CreditPartyName {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.CreditPartyName[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.DebitPartyName != nil {
					v.Result.ResultParameters.ResultParameter.DebitPartyName = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.DebitPartyName))
					for key, val := range body.Result.ResultParameters.ResultParameter.DebitPartyName {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.DebitPartyName[tk] = tv
					}
				}
			}
		}
		if body.Result.ReferenceData != nil {
			v.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if body.Result.ReferenceData.ReferenceItem != nil {
				v.Result.ReferenceData.ReferenceItem = make(map[string]string, len(body.Result.ReferenceData.ReferenceItem))
				for key, val := range body.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					v.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}

	return v
}

// NewTransactionStatusResult builds a mpesa service TransactionStatusResult
// endpoint payload.
func NewTransactionStatusResult(body *TransactionStatusResultRequestBody) *mpesa.TransactionStatusResult {
	v := &mpesa.TransactionStatusResult{}
	if body.Result != nil {
		v.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ResultParameters         *struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}
			ReferenceData *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               body.Result.ResultType,
			ResultCode:               body.Result.ResultCode,
			ResultDesc:               body.Result.ResultDesc,
			OriginatorConversationID: body.Result.OriginatorConversationID,
			ConversationID:           body.Result.ConversationID,
			TransactionID:            body.Result.TransactionID,
		}
		if body.Result.ResultParameters != nil {
			v.Result.ResultParameters = &struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}{}
			if body.Result.ResultParameters.ResultParameter != nil {
				v.Result.ResultParameters.ResultParameter = &struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}{}
				if body.Result.ResultParameters.ResultParameter.ReceiptNo != nil {
					v.Result.ResultParameters.ResultParameter.ReceiptNo = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.ReceiptNo))
					for key, val := range body.Result.ResultParameters.ResultParameter.ReceiptNo {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.ReceiptNo[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.ConversationID != nil {
					v.Result.ResultParameters.ResultParameter.ConversationID = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.ConversationID))
					for key, val := range body.Result.ResultParameters.ResultParameter.ConversationID {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.ConversationID[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.FinalisedTime != nil {
					v.Result.ResultParameters.ResultParameter.FinalisedTime = make(map[string]int, len(body.Result.ResultParameters.ResultParameter.FinalisedTime))
					for key, val := range body.Result.ResultParameters.ResultParameter.FinalisedTime {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.FinalisedTime[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.Amount != nil {
					v.Result.ResultParameters.ResultParameter.Amount = make(map[string]int, len(body.Result.ResultParameters.ResultParameter.Amount))
					for key, val := range body.Result.ResultParameters.ResultParameter.Amount {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.Amount[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.TransactionStatus != nil {
					v.Result.ResultParameters.ResultParameter.TransactionStatus = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.TransactionStatus))
					for key, val := range body.Result.ResultParameters.ResultParameter.TransactionStatus {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.TransactionStatus[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.ReasonType != nil {
					v.Result.ResultParameters.ResultParameter.ReasonType = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.ReasonType))
					for key, val := range body.Result.ResultParameters.ResultParameter.ReasonType {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.ReasonType[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.TransactionReason != nil {
					v.Result.ResultParameters.ResultParameter.TransactionReason = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.TransactionReason))
					for key, val := range body.Result.ResultParameters.ResultParameter.TransactionReason {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.TransactionReason[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.DebitPartyCharges != nil {
					v.Result.ResultParameters.ResultParameter.DebitPartyCharges = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.DebitPartyCharges))
					for key, val := range body.Result.ResultParameters.ResultParameter.DebitPartyCharges {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.DebitPartyCharges[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.DebitAccountType != nil {
					v.Result.ResultParameters.ResultParameter.DebitAccountType = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.DebitAccountType))
					for key, val := range body.Result.ResultParameters.ResultParameter.DebitAccountType {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.DebitAccountType[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.InitiatedTime != nil {
					v.Result.ResultParameters.ResultParameter.InitiatedTime = make(map[string]int, len(body.Result.ResultParameters.ResultParameter.InitiatedTime))
					for key, val := range body.Result.ResultParameters.ResultParameter.InitiatedTime {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.InitiatedTime[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.OriginatorConversationID != nil {
					v.Result.ResultParameters.ResultParameter.OriginatorConversationID = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.OriginatorConversationID))
					for key, val := range body.Result.ResultParameters.ResultParameter.OriginatorConversationID {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.OriginatorConversationID[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.CreditPartyName != nil {
					v.Result.ResultParameters.ResultParameter.CreditPartyName = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.CreditPartyName))
					for key, val := range body.Result.ResultParameters.ResultParameter.CreditPartyName {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.CreditPartyName[tk] = tv
					}
				}
				if body.Result.ResultParameters.ResultParameter.DebitPartyName != nil {
					v.Result.ResultParameters.ResultParameter.DebitPartyName = make(map[string]string, len(body.Result.ResultParameters.ResultParameter.DebitPartyName))
					for key, val := range body.Result.ResultParameters.ResultParameter.DebitPartyName {
						tk := key
						tv := val
						v.Result.ResultParameters.ResultParameter.DebitPartyName[tk] = tv
					}
				}
			}
		}
		if body.Result.ReferenceData != nil {
			v.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if body.Result.ReferenceData.ReferenceItem != nil {
				v.Result.ReferenceData.ReferenceItem = make(map[string]string, len(body.Result.ReferenceData.ReferenceItem))
				for key, val := range body.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					v.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}

	return v
}

// NewReversalTimeoutReversalResult builds a mpesa service ReversalTimeout
// endpoint payload.
func NewReversalTimeoutReversalResult(body *ReversalTimeoutRequestBody) *mpesa.ReversalResult {
	v := &mpesa.ReversalResult{}
	if body.Result != nil {
		v.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ReferenceData            *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               body.Result.ResultType,
			ResultCode:               body.Result.ResultCode,
			ResultDesc:               body.Result.ResultDesc,
			OriginatorConversationID: body.Result.OriginatorConversationID,
			ConversationID:           body.Result.ConversationID,
			TransactionID:            body.Result.TransactionID,
		}
		if body.Result.ReferenceData != nil {
			v.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if body.Result.ReferenceData.ReferenceItem != nil {
				v.Result.ReferenceData.ReferenceItem = make(map[string]string, len(body.Result.ReferenceData.ReferenceItem))
				for key, val := range body.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					v.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}

	return v
}

// NewReversalResult builds a mpesa service ReversalResult endpoint payload.
func NewReversalResult(body *ReversalResultRequestBody) *mpesa.ReversalResult {
	v := &mpesa.ReversalResult{}
	if body.Result != nil {
		v.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ReferenceData            *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               body.Result.ResultType,
			ResultCode:               body.Result.ResultCode,
			ResultDesc:               body.Result.ResultDesc,
			OriginatorConversationID: body.Result.OriginatorConversationID,
			ConversationID:           body.Result.ConversationID,
			TransactionID:            body.Result.TransactionID,
		}
		if body.Result.ReferenceData != nil {
			v.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if body.Result.ReferenceData.ReferenceItem != nil {
				v.Result.ReferenceData.ReferenceItem = make(map[string]string, len(body.Result.ReferenceData.ReferenceItem))
				for key, val := range body.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					v.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}

	return v
}

// NewB2CTimeoutB2CPaymentResult builds a mpesa service B2CTimeout endpoint
// payload.
func NewB2CTimeoutB2CPaymentResult(body *B2CTimeoutRequestBody) *mpesa.B2CPaymentResult {
	v := &mpesa.B2CPaymentResult{}
	if body.Result != nil {
		v.Result = &struct {
			// Status code that indicates whether the transaction was already sent
			ResultType *int
			// Numeric status code that indicates the status of the transaction processing
			ResultCode *int
			// Message from the API that gives the status of the request
			ResultDesc *string
			// Global unique identifier for the transaction request.
			OriginatorConversationID *string
			// Global unique identifier for the transaction request.
			ConversationID *string
			// Unique M-PESA transaction ID for every payment request.
			TransactionID *string
		}{
			ResultCode:               body.Result.ResultCode,
			ResultDesc:               body.Result.ResultDesc,
			OriginatorConversationID: body.Result.OriginatorConversationID,
			ConversationID:           body.Result.ConversationID,
			TransactionID:            body.Result.TransactionID,
		}
		if body.Result.ResultType != nil {
			v.Result.ResultType = *body.Result.ResultType
		}
		if body.Result.ResultType == nil {
			v.Result.ResultType = 0
		}
	}
	if body.ResultParameters != nil {
		v.ResultParameters = &struct {
			ResultParameter *struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}
		}{}
		if body.ResultParameters.ResultParameter != nil {
			v.ResultParameters.ResultParameter = &struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}{}
			if body.ResultParameters.ResultParameter.TransactionReceipt != nil {
				v.ResultParameters.ResultParameter.TransactionReceipt = make(map[string]string, len(body.ResultParameters.ResultParameter.TransactionReceipt))
				for key, val := range body.ResultParameters.ResultParameter.TransactionReceipt {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.TransactionReceipt[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.TransactionAmount != nil {
				v.ResultParameters.ResultParameter.TransactionAmount = make(map[string]int, len(body.ResultParameters.ResultParameter.TransactionAmount))
				for key, val := range body.ResultParameters.ResultParameter.TransactionAmount {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.TransactionAmount[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds != nil {
				v.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds = make(map[string]int, len(body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds))
				for key, val := range body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds != nil {
				v.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds = make(map[string]int, len(body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds))
				for key, val := range body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.TransactionCompletedDateTime != nil {
				v.ResultParameters.ResultParameter.TransactionCompletedDateTime = make(map[string]string, len(body.ResultParameters.ResultParameter.TransactionCompletedDateTime))
				for key, val := range body.ResultParameters.ResultParameter.TransactionCompletedDateTime {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.TransactionCompletedDateTime[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.ReceiverPartyPublicName != nil {
				v.ResultParameters.ResultParameter.ReceiverPartyPublicName = make(map[string]string, len(body.ResultParameters.ResultParameter.ReceiverPartyPublicName))
				for key, val := range body.ResultParameters.ResultParameter.ReceiverPartyPublicName {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.ReceiverPartyPublicName[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds != nil {
				v.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds = make(map[string]int, len(body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds))
				for key, val := range body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer != nil {
				v.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer = make(map[string]string, len(body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer))
				for key, val := range body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[tk] = tv
				}
			}
		}
	}
	if body.ReferenceData != nil {
		v.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if body.ReferenceData.ReferenceItem != nil {
			v.ReferenceData.ReferenceItem = make(map[string]string, len(body.ReferenceData.ReferenceItem))
			for key, val := range body.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				v.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}

	return v
}

// NewB2CResultB2CPaymentResult builds a mpesa service B2CResult endpoint
// payload.
func NewB2CResultB2CPaymentResult(body *B2CResultRequestBody) *mpesa.B2CPaymentResult {
	v := &mpesa.B2CPaymentResult{}
	if body.Result != nil {
		v.Result = &struct {
			// Status code that indicates whether the transaction was already sent
			ResultType *int
			// Numeric status code that indicates the status of the transaction processing
			ResultCode *int
			// Message from the API that gives the status of the request
			ResultDesc *string
			// Global unique identifier for the transaction request.
			OriginatorConversationID *string
			// Global unique identifier for the transaction request.
			ConversationID *string
			// Unique M-PESA transaction ID for every payment request.
			TransactionID *string
		}{
			ResultCode:               body.Result.ResultCode,
			ResultDesc:               body.Result.ResultDesc,
			OriginatorConversationID: body.Result.OriginatorConversationID,
			ConversationID:           body.Result.ConversationID,
			TransactionID:            body.Result.TransactionID,
		}
		if body.Result.ResultType != nil {
			v.Result.ResultType = *body.Result.ResultType
		}
		if body.Result.ResultType == nil {
			v.Result.ResultType = 0
		}
	}
	if body.ResultParameters != nil {
		v.ResultParameters = &struct {
			ResultParameter *struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}
		}{}
		if body.ResultParameters.ResultParameter != nil {
			v.ResultParameters.ResultParameter = &struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}{}
			if body.ResultParameters.ResultParameter.TransactionReceipt != nil {
				v.ResultParameters.ResultParameter.TransactionReceipt = make(map[string]string, len(body.ResultParameters.ResultParameter.TransactionReceipt))
				for key, val := range body.ResultParameters.ResultParameter.TransactionReceipt {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.TransactionReceipt[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.TransactionAmount != nil {
				v.ResultParameters.ResultParameter.TransactionAmount = make(map[string]int, len(body.ResultParameters.ResultParameter.TransactionAmount))
				for key, val := range body.ResultParameters.ResultParameter.TransactionAmount {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.TransactionAmount[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds != nil {
				v.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds = make(map[string]int, len(body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds))
				for key, val := range body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds != nil {
				v.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds = make(map[string]int, len(body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds))
				for key, val := range body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.TransactionCompletedDateTime != nil {
				v.ResultParameters.ResultParameter.TransactionCompletedDateTime = make(map[string]string, len(body.ResultParameters.ResultParameter.TransactionCompletedDateTime))
				for key, val := range body.ResultParameters.ResultParameter.TransactionCompletedDateTime {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.TransactionCompletedDateTime[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.ReceiverPartyPublicName != nil {
				v.ResultParameters.ResultParameter.ReceiverPartyPublicName = make(map[string]string, len(body.ResultParameters.ResultParameter.ReceiverPartyPublicName))
				for key, val := range body.ResultParameters.ResultParameter.ReceiverPartyPublicName {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.ReceiverPartyPublicName[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds != nil {
				v.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds = make(map[string]int, len(body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds))
				for key, val := range body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds[tk] = tv
				}
			}
			if body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer != nil {
				v.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer = make(map[string]string, len(body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer))
				for key, val := range body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer {
					tk := key
					tv := val
					v.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[tk] = tv
				}
			}
		}
	}
	if body.ReferenceData != nil {
		v.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if body.ReferenceData.ReferenceItem != nil {
			v.ReferenceData.ReferenceItem = make(map[string]string, len(body.ReferenceData.ReferenceItem))
			for key, val := range body.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				v.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}

	return v
}

// NewC2BValidationValidationResult builds a mpesa service C2BValidation
// endpoint payload.
func NewC2BValidationValidationResult(body *C2BValidationRequestBody) *mpesa.ValidationResult {
	v := &mpesa.ValidationResult{
		TransactionType:   body.TransactionType,
		TransID:           body.TransID,
		TransTime:         body.TransTime,
		TransAmount:       body.TransAmount,
		BusinessShortCode: body.BusinessShortCode,
		BillRefNumber:     body.BillRefNumber,
		InvoiceNumber:     body.InvoiceNumber,
		OrgAccountBalance: body.OrgAccountBalance,
		ThirdPartyTransID: body.ThirdPartyTransID,
		MSISDN:            body.MSISDN,
		FirstName:         body.FirstName,
		MiddleName:        body.MiddleName,
		LastName:          body.LastName,
	}

	return v
}

// NewC2BConfirmationConfirmationResult builds a mpesa service C2BConfirmation
// endpoint payload.
func NewC2BConfirmationConfirmationResult(body *C2BConfirmationRequestBody) *mpesa.ConfirmationResult {
	v := &mpesa.ConfirmationResult{
		TransactionType:   body.TransactionType,
		TransID:           body.TransID,
		TransTime:         body.TransTime,
		TransAmount:       body.TransAmount,
		BusinessShortCode: body.BusinessShortCode,
		BillRefNumber:     body.BillRefNumber,
		InvoiceNumber:     body.InvoiceNumber,
		OrgAccountBalance: body.OrgAccountBalance,
		ThirdPartyTransID: body.ThirdPartyTransID,
		MSISDN:            body.MSISDN,
		FirstName:         body.FirstName,
		MiddleName:        body.MiddleName,
		LastName:          body.LastName,
	}

	return v
}

// ValidateAccountBalanceTimeoutRequestBody runs the validations defined on
// AccountBalanceTimeoutRequestBody
func ValidateAccountBalanceTimeoutRequestBody(body *AccountBalanceTimeoutRequestBody) (err error) {
	if body.ResultParameters != nil {
		if body.ResultParameters.ResultParameter != nil {
			for k, v := range body.ResultParameters.ResultParameter.AccountBalance {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.AccountBalance.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.AccountBalance[key]", v, "[a-zA-Z]+"))
			}
			for k, v := range body.ResultParameters.ResultParameter.BOCompletedTime {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.BOCompletedTime.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidateFormat("body.ResultParameters.ResultParameter.BOCompletedTime[key]", v, goa.FormatDateTime))

			}
		}
	}
	if body.ReferenceData != nil {
		for k, v := range body.ReferenceData.ReferenceItem {
			if utf8.RuneCountInString(k) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
			}
			err = goa.MergeErrors(err, goa.ValidatePattern("body.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
		}
	}
	return
}

// ValidateAccountBalanceResultRequestBody runs the validations defined on
// AccountBalanceResultRequestBody
func ValidateAccountBalanceResultRequestBody(body *AccountBalanceResultRequestBody) (err error) {
	if body.ResultParameters != nil {
		if body.ResultParameters.ResultParameter != nil {
			for k, v := range body.ResultParameters.ResultParameter.AccountBalance {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.AccountBalance.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.AccountBalance[key]", v, "[a-zA-Z]+"))
			}
			for k, v := range body.ResultParameters.ResultParameter.BOCompletedTime {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.BOCompletedTime.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidateFormat("body.ResultParameters.ResultParameter.BOCompletedTime[key]", v, goa.FormatDateTime))

			}
		}
	}
	if body.ReferenceData != nil {
		for k, v := range body.ReferenceData.ReferenceItem {
			if utf8.RuneCountInString(k) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
			}
			err = goa.MergeErrors(err, goa.ValidatePattern("body.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
		}
	}
	return
}

// ValidateTransactionStatusTimeoutRequestBody runs the validations defined on
// TransactionStatusTimeoutRequestBody
func ValidateTransactionStatusTimeoutRequestBody(body *TransactionStatusTimeoutRequestBody) (err error) {
	if body.Result != nil {
		if body.Result.ReferenceData != nil {
			for k, v := range body.Result.ReferenceData.ReferenceItem {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.Result.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.Result.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
			}
		}
	}
	return
}

// ValidateTransactionStatusResultRequestBody runs the validations defined on
// TransactionStatusResultRequestBody
func ValidateTransactionStatusResultRequestBody(body *TransactionStatusResultRequestBody) (err error) {
	if body.Result != nil {
		if body.Result.ReferenceData != nil {
			for k, v := range body.Result.ReferenceData.ReferenceItem {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.Result.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.Result.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
			}
		}
	}
	return
}

// ValidateReversalTimeoutRequestBody runs the validations defined on
// ReversalTimeoutRequestBody
func ValidateReversalTimeoutRequestBody(body *ReversalTimeoutRequestBody) (err error) {
	if body.Result != nil {
		if body.Result.ReferenceData != nil {
			for k, v := range body.Result.ReferenceData.ReferenceItem {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.Result.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.Result.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
			}
		}
	}
	return
}

// ValidateReversalResultRequestBody runs the validations defined on
// ReversalResultRequestBody
func ValidateReversalResultRequestBody(body *ReversalResultRequestBody) (err error) {
	if body.Result != nil {
		if body.Result.ReferenceData != nil {
			for k, v := range body.Result.ReferenceData.ReferenceItem {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.Result.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.Result.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
			}
		}
	}
	return
}

// ValidateB2CTimeoutRequestBody runs the validations defined on
// B2CTimeoutRequestBody
func ValidateB2CTimeoutRequestBody(body *B2CTimeoutRequestBody) (err error) {
	if body.Result != nil {
		if body.Result.ResultDesc != nil {
			if !(*body.Result.ResultDesc == "Service request is has bee accepted successfully" || *body.Result.ResultDesc == "Initiator information is invalid") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Result.ResultDesc", *body.Result.ResultDesc, []interface{}{"Service request is has bee accepted successfully", "Initiator information is invalid"}))
			}
		}
	}
	if body.ResultParameters != nil {
		if body.ResultParameters.ResultParameter != nil {
			for k, v := range body.ResultParameters.ResultParameter.TransactionReceipt {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.TransactionReceipt.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.TransactionReceipt[key]", v, "[a-zA-Z]+"))
			}
			for k, _ := range body.ResultParameters.ResultParameter.TransactionAmount {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.TransactionAmount.key", k, utf8.RuneCountInString(k), 1, true))
				}
			}
			for k, _ := range body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds.key", k, utf8.RuneCountInString(k), 1, true))
				}
			}
			for k, _ := range body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds.key", k, utf8.RuneCountInString(k), 1, true))
				}
			}
			for k, v := range body.ResultParameters.ResultParameter.TransactionCompletedDateTime {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.TransactionCompletedDateTime.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidateFormat("body.ResultParameters.ResultParameter.TransactionCompletedDateTime[key]", v, goa.FormatDateTime))

			}
			for k, v := range body.ResultParameters.ResultParameter.ReceiverPartyPublicName {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.ReceiverPartyPublicName.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.ReceiverPartyPublicName[key]", v, "[a-zA-Z]+"))
			}
			for k, v := range body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds.key", k, utf8.RuneCountInString(k), 1, true))
				}
				if v < 0 {
					err = goa.MergeErrors(err, goa.InvalidRangeError("body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds[key]", v, 0, true))
				}
			}
			for k, v := range body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer.key", k, utf8.RuneCountInString(k), 1, true))
				}
				if !(v == "Y" || v == "N") {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[key]", v, []interface{}{"Y", "N"}))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[key]", v, "[a-zA-Z]+"))
			}
		}
	}
	if body.ReferenceData != nil {
		for k, v := range body.ReferenceData.ReferenceItem {
			if utf8.RuneCountInString(k) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
			}
			err = goa.MergeErrors(err, goa.ValidatePattern("body.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
		}
	}
	return
}

// ValidateB2CResultRequestBody runs the validations defined on
// B2CResultRequestBody
func ValidateB2CResultRequestBody(body *B2CResultRequestBody) (err error) {
	if body.Result != nil {
		if body.Result.ResultDesc != nil {
			if !(*body.Result.ResultDesc == "Service request is has bee accepted successfully" || *body.Result.ResultDesc == "Initiator information is invalid") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.Result.ResultDesc", *body.Result.ResultDesc, []interface{}{"Service request is has bee accepted successfully", "Initiator information is invalid"}))
			}
		}
	}
	if body.ResultParameters != nil {
		if body.ResultParameters.ResultParameter != nil {
			for k, v := range body.ResultParameters.ResultParameter.TransactionReceipt {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.TransactionReceipt.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.TransactionReceipt[key]", v, "[a-zA-Z]+"))
			}
			for k, _ := range body.ResultParameters.ResultParameter.TransactionAmount {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.TransactionAmount.key", k, utf8.RuneCountInString(k), 1, true))
				}
			}
			for k, _ := range body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds.key", k, utf8.RuneCountInString(k), 1, true))
				}
			}
			for k, _ := range body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds.key", k, utf8.RuneCountInString(k), 1, true))
				}
			}
			for k, v := range body.ResultParameters.ResultParameter.TransactionCompletedDateTime {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.TransactionCompletedDateTime.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidateFormat("body.ResultParameters.ResultParameter.TransactionCompletedDateTime[key]", v, goa.FormatDateTime))

			}
			for k, v := range body.ResultParameters.ResultParameter.ReceiverPartyPublicName {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.ReceiverPartyPublicName.key", k, utf8.RuneCountInString(k), 1, true))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.ReceiverPartyPublicName[key]", v, "[a-zA-Z]+"))
			}
			for k, v := range body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds.key", k, utf8.RuneCountInString(k), 1, true))
				}
				if v < 0 {
					err = goa.MergeErrors(err, goa.InvalidRangeError("body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds[key]", v, 0, true))
				}
			}
			for k, v := range body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer {
				if utf8.RuneCountInString(k) < 1 {
					err = goa.MergeErrors(err, goa.InvalidLengthError("body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer.key", k, utf8.RuneCountInString(k), 1, true))
				}
				if !(v == "Y" || v == "N") {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[key]", v, []interface{}{"Y", "N"}))
				}
				err = goa.MergeErrors(err, goa.ValidatePattern("body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[key]", v, "[a-zA-Z]+"))
			}
		}
	}
	if body.ReferenceData != nil {
		for k, v := range body.ReferenceData.ReferenceItem {
			if utf8.RuneCountInString(k) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.ReferenceData.ReferenceItem.key", k, utf8.RuneCountInString(k), 1, true))
			}
			err = goa.MergeErrors(err, goa.ValidatePattern("body.ReferenceData.ReferenceItem[key]", v, "[a-zA-Z]+"))
		}
	}
	return
}

// ValidateC2BValidationRequestBody runs the validations defined on
// C2BValidationRequestBody
func ValidateC2BValidationRequestBody(body *C2BValidationRequestBody) (err error) {
	if body.TransactionType != nil {
		if !(*body.TransactionType == "Buy Goods" || *body.TransactionType == "Pay Bill") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.TransactionType", *body.TransactionType, []interface{}{"Buy Goods", "Pay Bill"}))
		}
	}
	if body.TransTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.TransTime", *body.TransTime, goa.FormatDateTime))
	}
	if body.BillRefNumber != nil {
		if utf8.RuneCountInString(*body.BillRefNumber) > 20 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.BillRefNumber", *body.BillRefNumber, utf8.RuneCountInString(*body.BillRefNumber), 20, false))
		}
	}
	return
}

// ValidateC2BConfirmationRequestBody runs the validations defined on
// C2BConfirmationRequestBody
func ValidateC2BConfirmationRequestBody(body *C2BConfirmationRequestBody) (err error) {
	if body.TransactionType != nil {
		if !(*body.TransactionType == "Buy Goods" || *body.TransactionType == "Pay Bill") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.TransactionType", *body.TransactionType, []interface{}{"Buy Goods", "Pay Bill"}))
		}
	}
	if body.TransTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.TransTime", *body.TransTime, goa.FormatDateTime))
	}
	if body.BillRefNumber != nil {
		if utf8.RuneCountInString(*body.BillRefNumber) > 20 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.BillRefNumber", *body.BillRefNumber, utf8.RuneCountInString(*body.BillRefNumber), 20, false))
		}
	}
	return
}
