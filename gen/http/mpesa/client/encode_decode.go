// Code generated by goa v3.1.2, DO NOT EDIT.
//
// mpesa HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/wondenge/listeners/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"

	mpesa "github.com/wondenge/listeners/gen/mpesa"
	goahttp "goa.design/goa/v3/http"
)

// BuildAccountBalanceTimeoutRequest instantiates a HTTP request object with
// method and path set to call the "mpesa" service "AccountBalanceTimeout"
// endpoint
func (c *Client) BuildAccountBalanceTimeoutRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountBalanceTimeoutMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "AccountBalanceTimeout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountBalanceTimeoutRequest returns an encoder for requests sent to
// the mpesa AccountBalanceTimeout server.
func EncodeAccountBalanceTimeoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.AccountBalanceResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "AccountBalanceTimeout", "*mpesa.AccountBalanceResult", v)
		}
		body := NewAccountBalanceTimeoutRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "AccountBalanceTimeout", err)
		}
		return nil
	}
}

// DecodeAccountBalanceTimeoutResponse returns a decoder for responses returned
// by the mpesa AccountBalanceTimeout endpoint. restoreBody controls whether
// the response body should be restored after having been read.
func DecodeAccountBalanceTimeoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "AccountBalanceTimeout", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "AccountBalanceTimeout", resp.StatusCode, string(body))
		}
	}
}

// BuildAccountBalanceResultEndpointRequest instantiates a HTTP request object
// with method and path set to call the "mpesa" service "AccountBalanceResult"
// endpoint
func (c *Client) BuildAccountBalanceResultEndpointRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountBalanceResultEndpointMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "AccountBalanceResult", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountBalanceResultEndpointRequest returns an encoder for requests
// sent to the mpesa AccountBalanceResult server.
func EncodeAccountBalanceResultEndpointRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.AccountBalanceResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "AccountBalanceResult", "*mpesa.AccountBalanceResult", v)
		}
		body := NewAccountBalanceResultRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "AccountBalanceResult", err)
		}
		return nil
	}
}

// DecodeAccountBalanceResultEndpointResponse returns a decoder for responses
// returned by the mpesa AccountBalanceResult endpoint. restoreBody controls
// whether the response body should be restored after having been read.
func DecodeAccountBalanceResultEndpointResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "AccountBalanceResult", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "AccountBalanceResult", resp.StatusCode, string(body))
		}
	}
}

// BuildTransactionStatusTimeoutRequest instantiates a HTTP request object with
// method and path set to call the "mpesa" service "TransactionStatusTimeout"
// endpoint
func (c *Client) BuildTransactionStatusTimeoutRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: TransactionStatusTimeoutMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "TransactionStatusTimeout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeTransactionStatusTimeoutRequest returns an encoder for requests sent
// to the mpesa TransactionStatusTimeout server.
func EncodeTransactionStatusTimeoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.TransactionStatusResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "TransactionStatusTimeout", "*mpesa.TransactionStatusResult", v)
		}
		body := NewTransactionStatusTimeoutRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "TransactionStatusTimeout", err)
		}
		return nil
	}
}

// DecodeTransactionStatusTimeoutResponse returns a decoder for responses
// returned by the mpesa TransactionStatusTimeout endpoint. restoreBody
// controls whether the response body should be restored after having been read.
func DecodeTransactionStatusTimeoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "TransactionStatusTimeout", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "TransactionStatusTimeout", resp.StatusCode, string(body))
		}
	}
}

// BuildTransactionStatusResultEndpointRequest instantiates a HTTP request
// object with method and path set to call the "mpesa" service
// "TransactionStatusResult" endpoint
func (c *Client) BuildTransactionStatusResultEndpointRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: TransactionStatusResultEndpointMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "TransactionStatusResult", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeTransactionStatusResultEndpointRequest returns an encoder for requests
// sent to the mpesa TransactionStatusResult server.
func EncodeTransactionStatusResultEndpointRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.TransactionStatusResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "TransactionStatusResult", "*mpesa.TransactionStatusResult", v)
		}
		body := NewTransactionStatusResultRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "TransactionStatusResult", err)
		}
		return nil
	}
}

// DecodeTransactionStatusResultEndpointResponse returns a decoder for
// responses returned by the mpesa TransactionStatusResult endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
func DecodeTransactionStatusResultEndpointResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "TransactionStatusResult", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "TransactionStatusResult", resp.StatusCode, string(body))
		}
	}
}

// BuildReversalTimeoutRequest instantiates a HTTP request object with method
// and path set to call the "mpesa" service "ReversalTimeout" endpoint
func (c *Client) BuildReversalTimeoutRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReversalTimeoutMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "ReversalTimeout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReversalTimeoutRequest returns an encoder for requests sent to the
// mpesa ReversalTimeout server.
func EncodeReversalTimeoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.ReversalResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "ReversalTimeout", "*mpesa.ReversalResult", v)
		}
		body := NewReversalTimeoutRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "ReversalTimeout", err)
		}
		return nil
	}
}

// DecodeReversalTimeoutResponse returns a decoder for responses returned by
// the mpesa ReversalTimeout endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeReversalTimeoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "ReversalTimeout", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "ReversalTimeout", resp.StatusCode, string(body))
		}
	}
}

// BuildReversalResultEndpointRequest instantiates a HTTP request object with
// method and path set to call the "mpesa" service "ReversalResult" endpoint
func (c *Client) BuildReversalResultEndpointRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReversalResultEndpointMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "ReversalResult", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReversalResultEndpointRequest returns an encoder for requests sent to
// the mpesa ReversalResult server.
func EncodeReversalResultEndpointRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.ReversalResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "ReversalResult", "*mpesa.ReversalResult", v)
		}
		body := NewReversalResultRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "ReversalResult", err)
		}
		return nil
	}
}

// DecodeReversalResultEndpointResponse returns a decoder for responses
// returned by the mpesa ReversalResult endpoint. restoreBody controls whether
// the response body should be restored after having been read.
func DecodeReversalResultEndpointResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "ReversalResult", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "ReversalResult", resp.StatusCode, string(body))
		}
	}
}

// BuildB2CTimeoutRequest instantiates a HTTP request object with method and
// path set to call the "mpesa" service "B2CTimeout" endpoint
func (c *Client) BuildB2CTimeoutRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: B2CTimeoutMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "B2CTimeout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeB2CTimeoutRequest returns an encoder for requests sent to the mpesa
// B2CTimeout server.
func EncodeB2CTimeoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.B2CPaymentResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "B2CTimeout", "*mpesa.B2CPaymentResult", v)
		}
		body := NewB2CTimeoutRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "B2CTimeout", err)
		}
		return nil
	}
}

// DecodeB2CTimeoutResponse returns a decoder for responses returned by the
// mpesa B2CTimeout endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeB2CTimeoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "B2CTimeout", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "B2CTimeout", resp.StatusCode, string(body))
		}
	}
}

// BuildB2CResultRequest instantiates a HTTP request object with method and
// path set to call the "mpesa" service "B2CResult" endpoint
func (c *Client) BuildB2CResultRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: B2CResultMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "B2CResult", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeB2CResultRequest returns an encoder for requests sent to the mpesa
// B2CResult server.
func EncodeB2CResultRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.B2CPaymentResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "B2CResult", "*mpesa.B2CPaymentResult", v)
		}
		body := NewB2CResultRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "B2CResult", err)
		}
		return nil
	}
}

// DecodeB2CResultResponse returns a decoder for responses returned by the
// mpesa B2CResult endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeB2CResultResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "B2CResult", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "B2CResult", resp.StatusCode, string(body))
		}
	}
}

// BuildC2BValidationRequest instantiates a HTTP request object with method and
// path set to call the "mpesa" service "C2BValidation" endpoint
func (c *Client) BuildC2BValidationRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: C2BValidationMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "C2BValidation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeC2BValidationRequest returns an encoder for requests sent to the mpesa
// C2BValidation server.
func EncodeC2BValidationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.ValidationResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "C2BValidation", "*mpesa.ValidationResult", v)
		}
		body := NewC2BValidationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "C2BValidation", err)
		}
		return nil
	}
}

// DecodeC2BValidationResponse returns a decoder for responses returned by the
// mpesa C2BValidation endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeC2BValidationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "C2BValidation", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "C2BValidation", resp.StatusCode, string(body))
		}
	}
}

// BuildC2BConfirmationRequest instantiates a HTTP request object with method
// and path set to call the "mpesa" service "C2BConfirmation" endpoint
func (c *Client) BuildC2BConfirmationRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: C2BConfirmationMpesaPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("mpesa", "C2BConfirmation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeC2BConfirmationRequest returns an encoder for requests sent to the
// mpesa C2BConfirmation server.
func EncodeC2BConfirmationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*mpesa.ConfirmationResult)
		if !ok {
			return goahttp.ErrInvalidType("mpesa", "C2BConfirmation", "*mpesa.ConfirmationResult", v)
		}
		body := NewC2BConfirmationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("mpesa", "C2BConfirmation", err)
		}
		return nil
	}
}

// DecodeC2BConfirmationResponse returns a decoder for responses returned by
// the mpesa C2BConfirmation endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeC2BConfirmationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("mpesa", "C2BConfirmation", err)
			}
			return body, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("mpesa", "C2BConfirmation", resp.StatusCode, string(body))
		}
	}
}
