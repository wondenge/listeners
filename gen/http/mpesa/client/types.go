// Code generated by goa v3.1.2, DO NOT EDIT.
//
// mpesa HTTP client types
//
// Command:
// $ goa gen github.com/wondenge/listeners/design

package client

import (
	mpesa "github.com/wondenge/listeners/gen/mpesa"
)

// AccountBalanceTimeoutRequestBody is the type of the "mpesa" service
// "AccountBalanceTimeout" endpoint HTTP request body.
type AccountBalanceTimeoutRequestBody struct {
	ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
	OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
	ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
	TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	ResultParameters         *struct {
		ResultParameter *struct {
			AccountBalance  map[string]string `form:"AccountBalance,omitempty" json:"AccountBalance,omitempty" xml:"AccountBalance,omitempty"`
			BOCompletedTime map[string]string `form:"BOCompletedTime,omitempty" json:"BOCompletedTime,omitempty" xml:"BOCompletedTime,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// AccountBalanceResultRequestBody is the type of the "mpesa" service
// "AccountBalanceResult" endpoint HTTP request body.
type AccountBalanceResultRequestBody struct {
	ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
	OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
	ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
	TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	ResultParameters         *struct {
		ResultParameter *struct {
			AccountBalance  map[string]string `form:"AccountBalance,omitempty" json:"AccountBalance,omitempty" xml:"AccountBalance,omitempty"`
			BOCompletedTime map[string]string `form:"BOCompletedTime,omitempty" json:"BOCompletedTime,omitempty" xml:"BOCompletedTime,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// TransactionStatusTimeoutRequestBody is the type of the "mpesa" service
// "TransactionStatusTimeout" endpoint HTTP request body.
type TransactionStatusTimeoutRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ResultParameters         *struct {
			ResultParameter *struct {
				ReceiptNo                map[string]string `form:"ReceiptNo,omitempty" json:"ReceiptNo,omitempty" xml:"ReceiptNo,omitempty"`
				ConversationID           map[string]string `form:"Conversation ID,omitempty" json:"Conversation ID,omitempty" xml:"Conversation ID,omitempty"`
				FinalisedTime            map[string]int    `form:"FinalisedTime,omitempty" json:"FinalisedTime,omitempty" xml:"FinalisedTime,omitempty"`
				Amount                   map[string]int    `form:"Amount,omitempty" json:"Amount,omitempty" xml:"Amount,omitempty"`
				TransactionStatus        map[string]string `form:"TransactionStatus,omitempty" json:"TransactionStatus,omitempty" xml:"TransactionStatus,omitempty"`
				ReasonType               map[string]string `form:"ReasonType,omitempty" json:"ReasonType,omitempty" xml:"ReasonType,omitempty"`
				TransactionReason        map[string]string `form:"TransactionReason,omitempty" json:"TransactionReason,omitempty" xml:"TransactionReason,omitempty"`
				DebitPartyCharges        map[string]string `form:"DebitPartyCharges,omitempty" json:"DebitPartyCharges,omitempty" xml:"DebitPartyCharges,omitempty"`
				DebitAccountType         map[string]string `form:"DebitAccountType,omitempty" json:"DebitAccountType,omitempty" xml:"DebitAccountType,omitempty"`
				InitiatedTime            map[string]int    `form:"InitiatedTime,omitempty" json:"InitiatedTime,omitempty" xml:"InitiatedTime,omitempty"`
				OriginatorConversationID map[string]string `form:"Originator Conversation ID,omitempty" json:"Originator Conversation ID,omitempty" xml:"Originator Conversation ID,omitempty"`
				CreditPartyName          map[string]string `form:"CreditPartyName,omitempty" json:"CreditPartyName,omitempty" xml:"CreditPartyName,omitempty"`
				DebitPartyName           map[string]string `form:"DebitPartyName,omitempty" json:"DebitPartyName,omitempty" xml:"DebitPartyName,omitempty"`
			} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
		} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
		ReferenceData *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// TransactionStatusResultRequestBody is the type of the "mpesa" service
// "TransactionStatusResult" endpoint HTTP request body.
type TransactionStatusResultRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ResultParameters         *struct {
			ResultParameter *struct {
				ReceiptNo                map[string]string `form:"ReceiptNo,omitempty" json:"ReceiptNo,omitempty" xml:"ReceiptNo,omitempty"`
				ConversationID           map[string]string `form:"Conversation ID,omitempty" json:"Conversation ID,omitempty" xml:"Conversation ID,omitempty"`
				FinalisedTime            map[string]int    `form:"FinalisedTime,omitempty" json:"FinalisedTime,omitempty" xml:"FinalisedTime,omitempty"`
				Amount                   map[string]int    `form:"Amount,omitempty" json:"Amount,omitempty" xml:"Amount,omitempty"`
				TransactionStatus        map[string]string `form:"TransactionStatus,omitempty" json:"TransactionStatus,omitempty" xml:"TransactionStatus,omitempty"`
				ReasonType               map[string]string `form:"ReasonType,omitempty" json:"ReasonType,omitempty" xml:"ReasonType,omitempty"`
				TransactionReason        map[string]string `form:"TransactionReason,omitempty" json:"TransactionReason,omitempty" xml:"TransactionReason,omitempty"`
				DebitPartyCharges        map[string]string `form:"DebitPartyCharges,omitempty" json:"DebitPartyCharges,omitempty" xml:"DebitPartyCharges,omitempty"`
				DebitAccountType         map[string]string `form:"DebitAccountType,omitempty" json:"DebitAccountType,omitempty" xml:"DebitAccountType,omitempty"`
				InitiatedTime            map[string]int    `form:"InitiatedTime,omitempty" json:"InitiatedTime,omitempty" xml:"InitiatedTime,omitempty"`
				OriginatorConversationID map[string]string `form:"Originator Conversation ID,omitempty" json:"Originator Conversation ID,omitempty" xml:"Originator Conversation ID,omitempty"`
				CreditPartyName          map[string]string `form:"CreditPartyName,omitempty" json:"CreditPartyName,omitempty" xml:"CreditPartyName,omitempty"`
				DebitPartyName           map[string]string `form:"DebitPartyName,omitempty" json:"DebitPartyName,omitempty" xml:"DebitPartyName,omitempty"`
			} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
		} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
		ReferenceData *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// ReversalTimeoutRequestBody is the type of the "mpesa" service
// "ReversalTimeout" endpoint HTTP request body.
type ReversalTimeoutRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ReferenceData            *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// ReversalResultRequestBody is the type of the "mpesa" service
// "ReversalResult" endpoint HTTP request body.
type ReversalResultRequestBody struct {
	Result *struct {
		ResultType               *int    `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		ResultCode               *int    `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		ResultDesc               *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		OriginatorConversationID *string `form:"OriginatorConversationID,omitempty" json:"OriginatorConversationID,omitempty" xml:"OriginatorConversationID,omitempty"`
		ConversationID           *string `form:"ConversationID,omitempty" json:"ConversationID,omitempty" xml:"ConversationID,omitempty"`
		TransactionID            *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
		ReferenceData            *struct {
			ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
		} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
}

// B2CTimeoutRequestBody is the type of the "mpesa" service "B2CTimeout"
// endpoint HTTP request body.
type B2CTimeoutRequestBody struct {
	Result *struct {
		// Status code that indicates whether the transaction was already sent
		ResultType int `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		// Numeric status code that indicates the status of the transaction processing
		ResultCode *int `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		// Message from the API that gives the status of the request
		ResultDesc *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		// Global unique identifier for the transaction request.
		OriginatorConversationID *string `form:"OriginatorConversationId,omitempty" json:"OriginatorConversationId,omitempty" xml:"OriginatorConversationId,omitempty"`
		// Global unique identifier for the transaction request.
		ConversationID *string `form:"ConversationId,omitempty" json:"ConversationId,omitempty" xml:"ConversationId,omitempty"`
		// Unique M-PESA transaction ID for every payment request.
		TransactionID *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
	ResultParameters *struct {
		ResultParameter *struct {
			// This is a unique M-PESA transaction ID for every payment request.
			TransactionReceipt map[string]string `form:"TransactionReceipt,omitempty" json:"TransactionReceipt,omitempty" xml:"TransactionReceipt,omitempty"`
			// This is the amount that was transacted.
			TransactionAmount map[string]int `form:"TransactionAmount,omitempty" json:"TransactionAmount,omitempty" xml:"TransactionAmount,omitempty"`
			// Available balance of the Working account under the B2C shortcode used in the
			// transaction.
			B2CWorkingAccountAvailableFunds map[string]int `form:"B2CWorkingAccountAvailableFunds,omitempty" json:"B2CWorkingAccountAvailableFunds,omitempty" xml:"B2CWorkingAccountAvailableFunds,omitempty"`
			// Available balance of the Utility account under the B2C shortcode used in the
			// transaction.
			B2CUtilityAccountAvailableFunds map[string]int `form:"B2CUtilityAccountAvailableFunds,omitempty" json:"B2CUtilityAccountAvailableFunds,omitempty" xml:"B2CUtilityAccountAvailableFunds,omitempty"`
			// This is the date and time that the transaction completed M-PESA.
			TransactionCompletedDateTime map[string]string `form:"TransactionCompletedDateTime,omitempty" json:"TransactionCompletedDateTime,omitempty" xml:"TransactionCompletedDateTime,omitempty"`
			// This is the name and phone number of the customer who received the payment.
			ReceiverPartyPublicName map[string]string `form:"ReceiverPartyPublicName,omitempty" json:"ReceiverPartyPublicName,omitempty" xml:"ReceiverPartyPublicName,omitempty"`
			// Available balance of the Charges Paid account under the B2C shortcode used
			// in the transaction.
			B2CChargesPaidAccountAvailableFunds map[string]int `form:"B2CChargesPaidAccountAvailableFunds,omitempty" json:"B2CChargesPaidAccountAvailableFunds,omitempty" xml:"B2CChargesPaidAccountAvailableFunds,omitempty"`
			// This is a key that indicates whether the customer is a M-PESA registered
			// customer or not
			B2CRecipientIsRegisteredCustomer map[string]string `form:"B2CRecipientIsRegisteredCustomer,omitempty" json:"B2CRecipientIsRegisteredCustomer,omitempty" xml:"B2CRecipientIsRegisteredCustomer,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// B2CResultRequestBody is the type of the "mpesa" service "B2CResult" endpoint
// HTTP request body.
type B2CResultRequestBody struct {
	Result *struct {
		// Status code that indicates whether the transaction was already sent
		ResultType int `form:"ResultType,omitempty" json:"ResultType,omitempty" xml:"ResultType,omitempty"`
		// Numeric status code that indicates the status of the transaction processing
		ResultCode *int `form:"ResultCode,omitempty" json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
		// Message from the API that gives the status of the request
		ResultDesc *string `form:"ResultDesc,omitempty" json:"ResultDesc,omitempty" xml:"ResultDesc,omitempty"`
		// Global unique identifier for the transaction request.
		OriginatorConversationID *string `form:"OriginatorConversationId,omitempty" json:"OriginatorConversationId,omitempty" xml:"OriginatorConversationId,omitempty"`
		// Global unique identifier for the transaction request.
		ConversationID *string `form:"ConversationId,omitempty" json:"ConversationId,omitempty" xml:"ConversationId,omitempty"`
		// Unique M-PESA transaction ID for every payment request.
		TransactionID *string `form:"TransactionID,omitempty" json:"TransactionID,omitempty" xml:"TransactionID,omitempty"`
	} `form:"Result,omitempty" json:"Result,omitempty" xml:"Result,omitempty"`
	ResultParameters *struct {
		ResultParameter *struct {
			// This is a unique M-PESA transaction ID for every payment request.
			TransactionReceipt map[string]string `form:"TransactionReceipt,omitempty" json:"TransactionReceipt,omitempty" xml:"TransactionReceipt,omitempty"`
			// This is the amount that was transacted.
			TransactionAmount map[string]int `form:"TransactionAmount,omitempty" json:"TransactionAmount,omitempty" xml:"TransactionAmount,omitempty"`
			// Available balance of the Working account under the B2C shortcode used in the
			// transaction.
			B2CWorkingAccountAvailableFunds map[string]int `form:"B2CWorkingAccountAvailableFunds,omitempty" json:"B2CWorkingAccountAvailableFunds,omitempty" xml:"B2CWorkingAccountAvailableFunds,omitempty"`
			// Available balance of the Utility account under the B2C shortcode used in the
			// transaction.
			B2CUtilityAccountAvailableFunds map[string]int `form:"B2CUtilityAccountAvailableFunds,omitempty" json:"B2CUtilityAccountAvailableFunds,omitempty" xml:"B2CUtilityAccountAvailableFunds,omitempty"`
			// This is the date and time that the transaction completed M-PESA.
			TransactionCompletedDateTime map[string]string `form:"TransactionCompletedDateTime,omitempty" json:"TransactionCompletedDateTime,omitempty" xml:"TransactionCompletedDateTime,omitempty"`
			// This is the name and phone number of the customer who received the payment.
			ReceiverPartyPublicName map[string]string `form:"ReceiverPartyPublicName,omitempty" json:"ReceiverPartyPublicName,omitempty" xml:"ReceiverPartyPublicName,omitempty"`
			// Available balance of the Charges Paid account under the B2C shortcode used
			// in the transaction.
			B2CChargesPaidAccountAvailableFunds map[string]int `form:"B2CChargesPaidAccountAvailableFunds,omitempty" json:"B2CChargesPaidAccountAvailableFunds,omitempty" xml:"B2CChargesPaidAccountAvailableFunds,omitempty"`
			// This is a key that indicates whether the customer is a M-PESA registered
			// customer or not
			B2CRecipientIsRegisteredCustomer map[string]string `form:"B2CRecipientIsRegisteredCustomer,omitempty" json:"B2CRecipientIsRegisteredCustomer,omitempty" xml:"B2CRecipientIsRegisteredCustomer,omitempty"`
		} `form:"ResultParameter,omitempty" json:"ResultParameter,omitempty" xml:"ResultParameter,omitempty"`
	} `form:"ResultParameters,omitempty" json:"ResultParameters,omitempty" xml:"ResultParameters,omitempty"`
	ReferenceData *struct {
		ReferenceItem map[string]string `form:"ReferenceItem,omitempty" json:"ReferenceItem,omitempty" xml:"ReferenceItem,omitempty"`
	} `form:"ReferenceData,omitempty" json:"ReferenceData,omitempty" xml:"ReferenceData,omitempty"`
}

// C2BValidationRequestBody is the type of the "mpesa" service "C2BValidation"
// endpoint HTTP request body.
type C2BValidationRequestBody struct {
	// The transaction type specified during the payment request.
	TransactionType *string `form:"TransactionType,omitempty" json:"TransactionType,omitempty" xml:"TransactionType,omitempty"`
	// Unique M-Pesa transaction ID for every payment request
	TransID *string `form:"TransID,omitempty" json:"TransID,omitempty" xml:"TransID,omitempty"`
	// Timestamp of the transaction
	TransTime *string `form:"TransTime,omitempty" json:"TransTime,omitempty" xml:"TransTime,omitempty"`
	// The Amount transacted normally a numeric value
	TransAmount *int `form:"TransAmount,omitempty" json:"TransAmount,omitempty" xml:"TransAmount,omitempty"`
	// Organizations shortcode (Paybill or Buygoods)
	BusinessShortCode *int `form:"BusinessShortCode,omitempty" json:"BusinessShortCode,omitempty" xml:"BusinessShortCode,omitempty"`
	// Account number for which the customer is making the payment
	BillRefNumber *string `form:"BillRefNumber,omitempty" json:"BillRefNumber,omitempty" xml:"BillRefNumber,omitempty"`
	InvoiceNumber *string `form:"InvoiceNumber,omitempty" json:"InvoiceNumber,omitempty" xml:"InvoiceNumber,omitempty"`
	// Current utility account balance of the payment receiving organization
	// shortcode
	OrgAccountBalance *int    `form:"OrgAccountBalance,omitempty" json:"OrgAccountBalance,omitempty" xml:"OrgAccountBalance,omitempty"`
	ThirdPartyTransID *string `form:"ThirdPartyTransID,omitempty" json:"ThirdPartyTransID,omitempty" xml:"ThirdPartyTransID,omitempty"`
	// Mobile number of the customer making the payment.
	MSISDN *int `form:"MSISDN,omitempty" json:"MSISDN,omitempty" xml:"MSISDN,omitempty"`
	// First Name of the customer making the payment.
	FirstName *string `form:"FirstName,omitempty" json:"FirstName,omitempty" xml:"FirstName,omitempty"`
	// Middle Name of the customer making the payment.
	MiddleName *string `form:"MiddleName,omitempty" json:"MiddleName,omitempty" xml:"MiddleName,omitempty"`
	// Last Name of the customer making payment.
	LastName *string `form:"LastName,omitempty" json:"LastName,omitempty" xml:"LastName,omitempty"`
}

// C2BConfirmationRequestBody is the type of the "mpesa" service
// "C2BConfirmation" endpoint HTTP request body.
type C2BConfirmationRequestBody struct {
	// The transaction type specified during the payment request.
	TransactionType *string `form:"TransactionType,omitempty" json:"TransactionType,omitempty" xml:"TransactionType,omitempty"`
	// Unique M-Pesa transaction ID for every payment request
	TransID *string `form:"TransID,omitempty" json:"TransID,omitempty" xml:"TransID,omitempty"`
	// Timestamp of the transaction
	TransTime *string `form:"TransTime,omitempty" json:"TransTime,omitempty" xml:"TransTime,omitempty"`
	// The Amount transacted normally a numeric value
	TransAmount *int `form:"TransAmount,omitempty" json:"TransAmount,omitempty" xml:"TransAmount,omitempty"`
	// Organizations shortcode (Paybill or Buygoods)
	BusinessShortCode *int `form:"BusinessShortCode,omitempty" json:"BusinessShortCode,omitempty" xml:"BusinessShortCode,omitempty"`
	// Account number for which the customer is making the payment
	BillRefNumber *string `form:"BillRefNumber,omitempty" json:"BillRefNumber,omitempty" xml:"BillRefNumber,omitempty"`
	InvoiceNumber *string `form:"InvoiceNumber,omitempty" json:"InvoiceNumber,omitempty" xml:"InvoiceNumber,omitempty"`
	// Current utility account balance of the payment receiving organization
	// shortcode
	OrgAccountBalance *int    `form:"OrgAccountBalance,omitempty" json:"OrgAccountBalance,omitempty" xml:"OrgAccountBalance,omitempty"`
	ThirdPartyTransID *string `form:"ThirdPartyTransID,omitempty" json:"ThirdPartyTransID,omitempty" xml:"ThirdPartyTransID,omitempty"`
	// Mobile number of the customer making the payment.
	MSISDN *int `form:"MSISDN,omitempty" json:"MSISDN,omitempty" xml:"MSISDN,omitempty"`
	// First Name of the customer making the payment.
	FirstName *string `form:"FirstName,omitempty" json:"FirstName,omitempty" xml:"FirstName,omitempty"`
	// Middle Name of the customer making the payment.
	MiddleName *string `form:"MiddleName,omitempty" json:"MiddleName,omitempty" xml:"MiddleName,omitempty"`
	// Last Name of the customer making payment.
	LastName *string `form:"LastName,omitempty" json:"LastName,omitempty" xml:"LastName,omitempty"`
}

// NewAccountBalanceTimeoutRequestBody builds the HTTP request body from the
// payload of the "AccountBalanceTimeout" endpoint of the "mpesa" service.
func NewAccountBalanceTimeoutRequestBody(p *mpesa.AccountBalanceResult) *AccountBalanceTimeoutRequestBody {
	body := &AccountBalanceTimeoutRequestBody{
		ResultType:               p.ResultType,
		ResultCode:               p.ResultCode,
		ResultDesc:               p.ResultDesc,
		OriginatorConversationID: p.OriginatorConversationID,
		ConversationID:           p.ConversationID,
		TransactionID:            p.TransactionID,
	}
	if p.ResultParameters != nil {
		body.ResultParameters = &struct {
			ResultParameter *struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}
		}{}
		if p.ResultParameters.ResultParameter != nil {
			body.ResultParameters.ResultParameter = &struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}{}
			if p.ResultParameters.ResultParameter.AccountBalance != nil {
				body.ResultParameters.ResultParameter.AccountBalance = make(map[string]string, len(p.ResultParameters.ResultParameter.AccountBalance))
				for key, val := range p.ResultParameters.ResultParameter.AccountBalance {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.AccountBalance[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.BOCompletedTime != nil {
				body.ResultParameters.ResultParameter.BOCompletedTime = make(map[string]string, len(p.ResultParameters.ResultParameter.BOCompletedTime))
				for key, val := range p.ResultParameters.ResultParameter.BOCompletedTime {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.BOCompletedTime[tk] = tv
				}
			}
		}
	}
	if p.ReferenceData != nil {
		body.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if p.ReferenceData.ReferenceItem != nil {
			body.ReferenceData.ReferenceItem = make(map[string]string, len(p.ReferenceData.ReferenceItem))
			for key, val := range p.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				body.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}
	return body
}

// NewAccountBalanceResultRequestBody builds the HTTP request body from the
// payload of the "AccountBalanceResult" endpoint of the "mpesa" service.
func NewAccountBalanceResultRequestBody(p *mpesa.AccountBalanceResult) *AccountBalanceResultRequestBody {
	body := &AccountBalanceResultRequestBody{
		ResultType:               p.ResultType,
		ResultCode:               p.ResultCode,
		ResultDesc:               p.ResultDesc,
		OriginatorConversationID: p.OriginatorConversationID,
		ConversationID:           p.ConversationID,
		TransactionID:            p.TransactionID,
	}
	if p.ResultParameters != nil {
		body.ResultParameters = &struct {
			ResultParameter *struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}
		}{}
		if p.ResultParameters.ResultParameter != nil {
			body.ResultParameters.ResultParameter = &struct {
				AccountBalance  map[string]string
				BOCompletedTime map[string]string
			}{}
			if p.ResultParameters.ResultParameter.AccountBalance != nil {
				body.ResultParameters.ResultParameter.AccountBalance = make(map[string]string, len(p.ResultParameters.ResultParameter.AccountBalance))
				for key, val := range p.ResultParameters.ResultParameter.AccountBalance {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.AccountBalance[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.BOCompletedTime != nil {
				body.ResultParameters.ResultParameter.BOCompletedTime = make(map[string]string, len(p.ResultParameters.ResultParameter.BOCompletedTime))
				for key, val := range p.ResultParameters.ResultParameter.BOCompletedTime {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.BOCompletedTime[tk] = tv
				}
			}
		}
	}
	if p.ReferenceData != nil {
		body.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if p.ReferenceData.ReferenceItem != nil {
			body.ReferenceData.ReferenceItem = make(map[string]string, len(p.ReferenceData.ReferenceItem))
			for key, val := range p.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				body.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}
	return body
}

// NewTransactionStatusTimeoutRequestBody builds the HTTP request body from the
// payload of the "TransactionStatusTimeout" endpoint of the "mpesa" service.
func NewTransactionStatusTimeoutRequestBody(p *mpesa.TransactionStatusResult) *TransactionStatusTimeoutRequestBody {
	body := &TransactionStatusTimeoutRequestBody{}
	if p.Result != nil {
		body.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ResultParameters         *struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}
			ReferenceData *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               p.Result.ResultType,
			ResultCode:               p.Result.ResultCode,
			ResultDesc:               p.Result.ResultDesc,
			OriginatorConversationID: p.Result.OriginatorConversationID,
			ConversationID:           p.Result.ConversationID,
			TransactionID:            p.Result.TransactionID,
		}
		if p.Result.ResultParameters != nil {
			body.Result.ResultParameters = &struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}{}
			if p.Result.ResultParameters.ResultParameter != nil {
				body.Result.ResultParameters.ResultParameter = &struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}{}
				if p.Result.ResultParameters.ResultParameter.ReceiptNo != nil {
					body.Result.ResultParameters.ResultParameter.ReceiptNo = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.ReceiptNo))
					for key, val := range p.Result.ResultParameters.ResultParameter.ReceiptNo {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.ReceiptNo[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.ConversationID != nil {
					body.Result.ResultParameters.ResultParameter.ConversationID = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.ConversationID))
					for key, val := range p.Result.ResultParameters.ResultParameter.ConversationID {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.ConversationID[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.FinalisedTime != nil {
					body.Result.ResultParameters.ResultParameter.FinalisedTime = make(map[string]int, len(p.Result.ResultParameters.ResultParameter.FinalisedTime))
					for key, val := range p.Result.ResultParameters.ResultParameter.FinalisedTime {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.FinalisedTime[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.Amount != nil {
					body.Result.ResultParameters.ResultParameter.Amount = make(map[string]int, len(p.Result.ResultParameters.ResultParameter.Amount))
					for key, val := range p.Result.ResultParameters.ResultParameter.Amount {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.Amount[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.TransactionStatus != nil {
					body.Result.ResultParameters.ResultParameter.TransactionStatus = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.TransactionStatus))
					for key, val := range p.Result.ResultParameters.ResultParameter.TransactionStatus {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.TransactionStatus[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.ReasonType != nil {
					body.Result.ResultParameters.ResultParameter.ReasonType = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.ReasonType))
					for key, val := range p.Result.ResultParameters.ResultParameter.ReasonType {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.ReasonType[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.TransactionReason != nil {
					body.Result.ResultParameters.ResultParameter.TransactionReason = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.TransactionReason))
					for key, val := range p.Result.ResultParameters.ResultParameter.TransactionReason {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.TransactionReason[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.DebitPartyCharges != nil {
					body.Result.ResultParameters.ResultParameter.DebitPartyCharges = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.DebitPartyCharges))
					for key, val := range p.Result.ResultParameters.ResultParameter.DebitPartyCharges {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.DebitPartyCharges[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.DebitAccountType != nil {
					body.Result.ResultParameters.ResultParameter.DebitAccountType = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.DebitAccountType))
					for key, val := range p.Result.ResultParameters.ResultParameter.DebitAccountType {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.DebitAccountType[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.InitiatedTime != nil {
					body.Result.ResultParameters.ResultParameter.InitiatedTime = make(map[string]int, len(p.Result.ResultParameters.ResultParameter.InitiatedTime))
					for key, val := range p.Result.ResultParameters.ResultParameter.InitiatedTime {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.InitiatedTime[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.OriginatorConversationID != nil {
					body.Result.ResultParameters.ResultParameter.OriginatorConversationID = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.OriginatorConversationID))
					for key, val := range p.Result.ResultParameters.ResultParameter.OriginatorConversationID {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.OriginatorConversationID[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.CreditPartyName != nil {
					body.Result.ResultParameters.ResultParameter.CreditPartyName = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.CreditPartyName))
					for key, val := range p.Result.ResultParameters.ResultParameter.CreditPartyName {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.CreditPartyName[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.DebitPartyName != nil {
					body.Result.ResultParameters.ResultParameter.DebitPartyName = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.DebitPartyName))
					for key, val := range p.Result.ResultParameters.ResultParameter.DebitPartyName {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.DebitPartyName[tk] = tv
					}
				}
			}
		}
		if p.Result.ReferenceData != nil {
			body.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if p.Result.ReferenceData.ReferenceItem != nil {
				body.Result.ReferenceData.ReferenceItem = make(map[string]string, len(p.Result.ReferenceData.ReferenceItem))
				for key, val := range p.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					body.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}
	return body
}

// NewTransactionStatusResultRequestBody builds the HTTP request body from the
// payload of the "TransactionStatusResult" endpoint of the "mpesa" service.
func NewTransactionStatusResultRequestBody(p *mpesa.TransactionStatusResult) *TransactionStatusResultRequestBody {
	body := &TransactionStatusResultRequestBody{}
	if p.Result != nil {
		body.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ResultParameters         *struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}
			ReferenceData *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               p.Result.ResultType,
			ResultCode:               p.Result.ResultCode,
			ResultDesc:               p.Result.ResultDesc,
			OriginatorConversationID: p.Result.OriginatorConversationID,
			ConversationID:           p.Result.ConversationID,
			TransactionID:            p.Result.TransactionID,
		}
		if p.Result.ResultParameters != nil {
			body.Result.ResultParameters = &struct {
				ResultParameter *struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}
			}{}
			if p.Result.ResultParameters.ResultParameter != nil {
				body.Result.ResultParameters.ResultParameter = &struct {
					ReceiptNo                map[string]string
					ConversationID           map[string]string
					FinalisedTime            map[string]int
					Amount                   map[string]int
					TransactionStatus        map[string]string
					ReasonType               map[string]string
					TransactionReason        map[string]string
					DebitPartyCharges        map[string]string
					DebitAccountType         map[string]string
					InitiatedTime            map[string]int
					OriginatorConversationID map[string]string
					CreditPartyName          map[string]string
					DebitPartyName           map[string]string
				}{}
				if p.Result.ResultParameters.ResultParameter.ReceiptNo != nil {
					body.Result.ResultParameters.ResultParameter.ReceiptNo = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.ReceiptNo))
					for key, val := range p.Result.ResultParameters.ResultParameter.ReceiptNo {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.ReceiptNo[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.ConversationID != nil {
					body.Result.ResultParameters.ResultParameter.ConversationID = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.ConversationID))
					for key, val := range p.Result.ResultParameters.ResultParameter.ConversationID {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.ConversationID[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.FinalisedTime != nil {
					body.Result.ResultParameters.ResultParameter.FinalisedTime = make(map[string]int, len(p.Result.ResultParameters.ResultParameter.FinalisedTime))
					for key, val := range p.Result.ResultParameters.ResultParameter.FinalisedTime {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.FinalisedTime[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.Amount != nil {
					body.Result.ResultParameters.ResultParameter.Amount = make(map[string]int, len(p.Result.ResultParameters.ResultParameter.Amount))
					for key, val := range p.Result.ResultParameters.ResultParameter.Amount {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.Amount[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.TransactionStatus != nil {
					body.Result.ResultParameters.ResultParameter.TransactionStatus = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.TransactionStatus))
					for key, val := range p.Result.ResultParameters.ResultParameter.TransactionStatus {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.TransactionStatus[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.ReasonType != nil {
					body.Result.ResultParameters.ResultParameter.ReasonType = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.ReasonType))
					for key, val := range p.Result.ResultParameters.ResultParameter.ReasonType {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.ReasonType[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.TransactionReason != nil {
					body.Result.ResultParameters.ResultParameter.TransactionReason = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.TransactionReason))
					for key, val := range p.Result.ResultParameters.ResultParameter.TransactionReason {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.TransactionReason[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.DebitPartyCharges != nil {
					body.Result.ResultParameters.ResultParameter.DebitPartyCharges = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.DebitPartyCharges))
					for key, val := range p.Result.ResultParameters.ResultParameter.DebitPartyCharges {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.DebitPartyCharges[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.DebitAccountType != nil {
					body.Result.ResultParameters.ResultParameter.DebitAccountType = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.DebitAccountType))
					for key, val := range p.Result.ResultParameters.ResultParameter.DebitAccountType {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.DebitAccountType[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.InitiatedTime != nil {
					body.Result.ResultParameters.ResultParameter.InitiatedTime = make(map[string]int, len(p.Result.ResultParameters.ResultParameter.InitiatedTime))
					for key, val := range p.Result.ResultParameters.ResultParameter.InitiatedTime {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.InitiatedTime[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.OriginatorConversationID != nil {
					body.Result.ResultParameters.ResultParameter.OriginatorConversationID = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.OriginatorConversationID))
					for key, val := range p.Result.ResultParameters.ResultParameter.OriginatorConversationID {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.OriginatorConversationID[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.CreditPartyName != nil {
					body.Result.ResultParameters.ResultParameter.CreditPartyName = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.CreditPartyName))
					for key, val := range p.Result.ResultParameters.ResultParameter.CreditPartyName {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.CreditPartyName[tk] = tv
					}
				}
				if p.Result.ResultParameters.ResultParameter.DebitPartyName != nil {
					body.Result.ResultParameters.ResultParameter.DebitPartyName = make(map[string]string, len(p.Result.ResultParameters.ResultParameter.DebitPartyName))
					for key, val := range p.Result.ResultParameters.ResultParameter.DebitPartyName {
						tk := key
						tv := val
						body.Result.ResultParameters.ResultParameter.DebitPartyName[tk] = tv
					}
				}
			}
		}
		if p.Result.ReferenceData != nil {
			body.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if p.Result.ReferenceData.ReferenceItem != nil {
				body.Result.ReferenceData.ReferenceItem = make(map[string]string, len(p.Result.ReferenceData.ReferenceItem))
				for key, val := range p.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					body.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}
	return body
}

// NewReversalTimeoutRequestBody builds the HTTP request body from the payload
// of the "ReversalTimeout" endpoint of the "mpesa" service.
func NewReversalTimeoutRequestBody(p *mpesa.ReversalResult) *ReversalTimeoutRequestBody {
	body := &ReversalTimeoutRequestBody{}
	if p.Result != nil {
		body.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ReferenceData            *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               p.Result.ResultType,
			ResultCode:               p.Result.ResultCode,
			ResultDesc:               p.Result.ResultDesc,
			OriginatorConversationID: p.Result.OriginatorConversationID,
			ConversationID:           p.Result.ConversationID,
			TransactionID:            p.Result.TransactionID,
		}
		if p.Result.ReferenceData != nil {
			body.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if p.Result.ReferenceData.ReferenceItem != nil {
				body.Result.ReferenceData.ReferenceItem = make(map[string]string, len(p.Result.ReferenceData.ReferenceItem))
				for key, val := range p.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					body.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}
	return body
}

// NewReversalResultRequestBody builds the HTTP request body from the payload
// of the "ReversalResult" endpoint of the "mpesa" service.
func NewReversalResultRequestBody(p *mpesa.ReversalResult) *ReversalResultRequestBody {
	body := &ReversalResultRequestBody{}
	if p.Result != nil {
		body.Result = &struct {
			ResultType               *int
			ResultCode               *int
			ResultDesc               *string
			OriginatorConversationID *string
			ConversationID           *string
			TransactionID            *string
			ReferenceData            *struct {
				ReferenceItem map[string]string
			}
		}{
			ResultType:               p.Result.ResultType,
			ResultCode:               p.Result.ResultCode,
			ResultDesc:               p.Result.ResultDesc,
			OriginatorConversationID: p.Result.OriginatorConversationID,
			ConversationID:           p.Result.ConversationID,
			TransactionID:            p.Result.TransactionID,
		}
		if p.Result.ReferenceData != nil {
			body.Result.ReferenceData = &struct {
				ReferenceItem map[string]string
			}{}
			if p.Result.ReferenceData.ReferenceItem != nil {
				body.Result.ReferenceData.ReferenceItem = make(map[string]string, len(p.Result.ReferenceData.ReferenceItem))
				for key, val := range p.Result.ReferenceData.ReferenceItem {
					tk := key
					tv := val
					body.Result.ReferenceData.ReferenceItem[tk] = tv
				}
			}
		}
	}
	return body
}

// NewB2CTimeoutRequestBody builds the HTTP request body from the payload of
// the "B2CTimeout" endpoint of the "mpesa" service.
func NewB2CTimeoutRequestBody(p *mpesa.B2CPaymentResult) *B2CTimeoutRequestBody {
	body := &B2CTimeoutRequestBody{}
	if p.Result != nil {
		body.Result = &struct {
			// Status code that indicates whether the transaction was already sent
			ResultType *int
			// Numeric status code that indicates the status of the transaction processing
			ResultCode *int
			// Message from the API that gives the status of the request
			ResultDesc *string
			// Global unique identifier for the transaction request.
			OriginatorConversationID *string
			// Global unique identifier for the transaction request.
			ConversationID *string
			// Unique M-PESA transaction ID for every payment request.
			TransactionID *string
		}{
			ResultType:               p.Result.ResultType,
			ResultCode:               p.Result.ResultCode,
			ResultDesc:               p.Result.ResultDesc,
			OriginatorConversationID: p.Result.OriginatorConversationID,
			ConversationID:           p.Result.ConversationID,
			TransactionID:            p.Result.TransactionID,
		}
	}
	if p.ResultParameters != nil {
		body.ResultParameters = &struct {
			ResultParameter *struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}
		}{}
		if p.ResultParameters.ResultParameter != nil {
			body.ResultParameters.ResultParameter = &struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}{}
			if p.ResultParameters.ResultParameter.TransactionReceipt != nil {
				body.ResultParameters.ResultParameter.TransactionReceipt = make(map[string]string, len(p.ResultParameters.ResultParameter.TransactionReceipt))
				for key, val := range p.ResultParameters.ResultParameter.TransactionReceipt {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.TransactionReceipt[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.TransactionAmount != nil {
				body.ResultParameters.ResultParameter.TransactionAmount = make(map[string]int, len(p.ResultParameters.ResultParameter.TransactionAmount))
				for key, val := range p.ResultParameters.ResultParameter.TransactionAmount {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.TransactionAmount[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds != nil {
				body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds = make(map[string]int, len(p.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds))
				for key, val := range p.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds != nil {
				body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds = make(map[string]int, len(p.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds))
				for key, val := range p.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.TransactionCompletedDateTime != nil {
				body.ResultParameters.ResultParameter.TransactionCompletedDateTime = make(map[string]string, len(p.ResultParameters.ResultParameter.TransactionCompletedDateTime))
				for key, val := range p.ResultParameters.ResultParameter.TransactionCompletedDateTime {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.TransactionCompletedDateTime[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.ReceiverPartyPublicName != nil {
				body.ResultParameters.ResultParameter.ReceiverPartyPublicName = make(map[string]string, len(p.ResultParameters.ResultParameter.ReceiverPartyPublicName))
				for key, val := range p.ResultParameters.ResultParameter.ReceiverPartyPublicName {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.ReceiverPartyPublicName[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds != nil {
				body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds = make(map[string]int, len(p.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds))
				for key, val := range p.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer != nil {
				body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer = make(map[string]string, len(p.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer))
				for key, val := range p.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[tk] = tv
				}
			}
		}
	}
	if p.ReferenceData != nil {
		body.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if p.ReferenceData.ReferenceItem != nil {
			body.ReferenceData.ReferenceItem = make(map[string]string, len(p.ReferenceData.ReferenceItem))
			for key, val := range p.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				body.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}
	return body
}

// NewB2CResultRequestBody builds the HTTP request body from the payload of the
// "B2CResult" endpoint of the "mpesa" service.
func NewB2CResultRequestBody(p *mpesa.B2CPaymentResult) *B2CResultRequestBody {
	body := &B2CResultRequestBody{}
	if p.Result != nil {
		body.Result = &struct {
			// Status code that indicates whether the transaction was already sent
			ResultType *int
			// Numeric status code that indicates the status of the transaction processing
			ResultCode *int
			// Message from the API that gives the status of the request
			ResultDesc *string
			// Global unique identifier for the transaction request.
			OriginatorConversationID *string
			// Global unique identifier for the transaction request.
			ConversationID *string
			// Unique M-PESA transaction ID for every payment request.
			TransactionID *string
		}{
			ResultType:               p.Result.ResultType,
			ResultCode:               p.Result.ResultCode,
			ResultDesc:               p.Result.ResultDesc,
			OriginatorConversationID: p.Result.OriginatorConversationID,
			ConversationID:           p.Result.ConversationID,
			TransactionID:            p.Result.TransactionID,
		}
	}
	if p.ResultParameters != nil {
		body.ResultParameters = &struct {
			ResultParameter *struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}
		}{}
		if p.ResultParameters.ResultParameter != nil {
			body.ResultParameters.ResultParameter = &struct {
				// This is a unique M-PESA transaction ID for every payment request.
				TransactionReceipt map[string]string
				// This is the amount that was transacted.
				TransactionAmount map[string]int
				// Available balance of the Working account under the B2C shortcode used in the
				// transaction.
				B2CWorkingAccountAvailableFunds map[string]int
				// Available balance of the Utility account under the B2C shortcode used in the
				// transaction.
				B2CUtilityAccountAvailableFunds map[string]int
				// This is the date and time that the transaction completed M-PESA.
				TransactionCompletedDateTime map[string]string
				// This is the name and phone number of the customer who received the payment.
				ReceiverPartyPublicName map[string]string
				// Available balance of the Charges Paid account under the B2C shortcode used
				// in the transaction.
				B2CChargesPaidAccountAvailableFunds map[string]int
				// This is a key that indicates whether the customer is a M-PESA registered
				// customer or not
				B2CRecipientIsRegisteredCustomer map[string]string
			}{}
			if p.ResultParameters.ResultParameter.TransactionReceipt != nil {
				body.ResultParameters.ResultParameter.TransactionReceipt = make(map[string]string, len(p.ResultParameters.ResultParameter.TransactionReceipt))
				for key, val := range p.ResultParameters.ResultParameter.TransactionReceipt {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.TransactionReceipt[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.TransactionAmount != nil {
				body.ResultParameters.ResultParameter.TransactionAmount = make(map[string]int, len(p.ResultParameters.ResultParameter.TransactionAmount))
				for key, val := range p.ResultParameters.ResultParameter.TransactionAmount {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.TransactionAmount[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds != nil {
				body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds = make(map[string]int, len(p.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds))
				for key, val := range p.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CWorkingAccountAvailableFunds[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds != nil {
				body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds = make(map[string]int, len(p.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds))
				for key, val := range p.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CUtilityAccountAvailableFunds[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.TransactionCompletedDateTime != nil {
				body.ResultParameters.ResultParameter.TransactionCompletedDateTime = make(map[string]string, len(p.ResultParameters.ResultParameter.TransactionCompletedDateTime))
				for key, val := range p.ResultParameters.ResultParameter.TransactionCompletedDateTime {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.TransactionCompletedDateTime[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.ReceiverPartyPublicName != nil {
				body.ResultParameters.ResultParameter.ReceiverPartyPublicName = make(map[string]string, len(p.ResultParameters.ResultParameter.ReceiverPartyPublicName))
				for key, val := range p.ResultParameters.ResultParameter.ReceiverPartyPublicName {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.ReceiverPartyPublicName[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds != nil {
				body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds = make(map[string]int, len(p.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds))
				for key, val := range p.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CChargesPaidAccountAvailableFunds[tk] = tv
				}
			}
			if p.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer != nil {
				body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer = make(map[string]string, len(p.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer))
				for key, val := range p.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer {
					tk := key
					tv := val
					body.ResultParameters.ResultParameter.B2CRecipientIsRegisteredCustomer[tk] = tv
				}
			}
		}
	}
	if p.ReferenceData != nil {
		body.ReferenceData = &struct {
			ReferenceItem map[string]string
		}{}
		if p.ReferenceData.ReferenceItem != nil {
			body.ReferenceData.ReferenceItem = make(map[string]string, len(p.ReferenceData.ReferenceItem))
			for key, val := range p.ReferenceData.ReferenceItem {
				tk := key
				tv := val
				body.ReferenceData.ReferenceItem[tk] = tv
			}
		}
	}
	return body
}

// NewC2BValidationRequestBody builds the HTTP request body from the payload of
// the "C2BValidation" endpoint of the "mpesa" service.
func NewC2BValidationRequestBody(p *mpesa.ValidationResult) *C2BValidationRequestBody {
	body := &C2BValidationRequestBody{
		TransactionType:   p.TransactionType,
		TransID:           p.TransID,
		TransTime:         p.TransTime,
		TransAmount:       p.TransAmount,
		BusinessShortCode: p.BusinessShortCode,
		BillRefNumber:     p.BillRefNumber,
		InvoiceNumber:     p.InvoiceNumber,
		OrgAccountBalance: p.OrgAccountBalance,
		ThirdPartyTransID: p.ThirdPartyTransID,
		MSISDN:            p.MSISDN,
		FirstName:         p.FirstName,
		MiddleName:        p.MiddleName,
		LastName:          p.LastName,
	}
	return body
}

// NewC2BConfirmationRequestBody builds the HTTP request body from the payload
// of the "C2BConfirmation" endpoint of the "mpesa" service.
func NewC2BConfirmationRequestBody(p *mpesa.ConfirmationResult) *C2BConfirmationRequestBody {
	body := &C2BConfirmationRequestBody{
		TransactionType:   p.TransactionType,
		TransID:           p.TransID,
		TransTime:         p.TransTime,
		TransAmount:       p.TransAmount,
		BusinessShortCode: p.BusinessShortCode,
		BillRefNumber:     p.BillRefNumber,
		InvoiceNumber:     p.InvoiceNumber,
		OrgAccountBalance: p.OrgAccountBalance,
		ThirdPartyTransID: p.ThirdPartyTransID,
		MSISDN:            p.MSISDN,
		FirstName:         p.FirstName,
		MiddleName:        p.MiddleName,
		LastName:          p.LastName,
	}
	return body
}
